---
title: "ModÃ©lisation dÃ©terministe"
author: "Serge-Ã‰tienne Parent"
date: "`r format(Sys.Date())`"
output: github_document
---

# ModÃ©lisation dÃ©terministe {#chapitre-ode}

On se rÃ©fÃ¨re Ã  la modÃ©lisation mÃ©canistique lorsque des principes thÃ©oriques guident une modÃ©lisation, Ã  l'inverse de la modÃ©lisation phÃ©nomÃ©nologique, qui est guidÃ©e par les donnÃ©es. Il existe de nombreuses techniques de modÃ©lisation mÃ©canistique, mais la plupart sont guidÃ©es par les Ã©quations diffÃ©rentielles.

## Ã‰quations diffÃ©rentielles
Les Ã©quations diffÃ©rentielles permettent la rÃ©solution de problÃ¨mes impliquant des gradients dans le temps et dans l'espace. On les utilise pour modÃ©liser la dynamique des populations, la thermodynamique, l'Ã©coulement de l'eau dans les sols, le transport des solutÃ©s, etc. On en distingue deux grandes catÃ©gories: les Ã©quations diffÃ©rentielles ordinaires et partielles.

**Ã‰quations diffÃ©rentielles ordinaires (EDO)**. Les Ã©quations diffÃ©rentielles ordinaires s'appliquent sur des fonctions s'appliquant Ã  une seule variables, qui est souvent le temps. On pourra suivre, par exemple, l'Ã©volution de la tempÃ©rature en un point, en fonction du temps Ã  partir d'une condition initiale. Parfois, plusieurs EDO sont utilisÃ©es conjointement pour crÃ©er un systÃ¨me d'EDO que l'on pourra nommÃ© un *systÃ¨me dynamique*. Les solutions analytiques des EDO sont parfois relativement faciles Ã  rÃ©soudre, mais les ordinateurs permettent des rÃ©solutions numÃ©riques en quelques lignes de code.

**Ã‰quations diffÃ©rentielles partielles (EDP)**. Dans ce cas, ce sont plusieurs variables qui sont diffÃ©renciÃ©es dans la mÃªme fonction. Il peut s'agir des coordonnÃ©es dans l'espace $[x, y, z]$ (rÃ©gime permanent), qui peuvent aussi Ãªtre appliquÃ©s Ã  diffÃ©rents pas de temps (rÃ©gime transitoire). Le problÃ¨me sera dÃ©limitÃ© non pas seulement par des conditions initiales, mais aussi par des conditions aux frontiÃ¨res du modÃ¨le. Puisque que les solutions analytiques des EDP peuvent rarement Ãªtre dÃ©veloppÃ©es, on utilisera pratiquement toujours des approches numÃ©riques que sont principalement les mÃ©thodes de rÃ©solution par diffÃ©rences finies ou par Ã©lÃ©ments finis.

## Objectifs

L'objectif de cette section est de vous initier Ã  la modÃ©lisation par Ã©quations diffÃ©rentielles sur `R`. Au terme de chapitre, vous serez en mesure de:

0. DÃ©tecter un problÃ¨me impliquant le besoin d'utiliser des Ã©quations diffÃ©rentielles
0. DiffÃ©rentier un problÃ¨me d'EDO et d'EDP
0. D'effectuer une modÃ©lisation impliquant un systÃ¨me d'EDO en contexte Ã©cologique
0. D'effectuer une modÃ©lisation par diffÃ©rences finies impliquant une EDP simple en contexte Ã©cologique

## Les Ã©quations diffÃ©rentielles ordinaires en modÃ©lisation Ã©cologique

L'Ã©volution des populations dans le temps peut Ãªtre abordÃ©e Ã  l'aide de systÃ¨mes d'Ã©quations diffÃ©rentielles. Une simple Ã©quation dÃ©crivant la croissance d'une population peut Ãªtre couplÃ©e Ã  des schÃ©mas d'exploitation de cette population, que ce soit une exploitation forestiÃ¨re, une terre fourragÃ¨re ou un territoire de chasse. On pourra aussi faire interagir des populations dans des schÃ©mas de relations biologiques. Ces processus peuvent Ãªtre implÃ©mentÃ©s avec des processus alÃ©atoires pour gÃ©nÃ©rer des schÃ©mas probabilistes. De plus, les biostatistiques et l'autoapprentissage peuvent Ãªtre mis Ã  contribution afin de calibrer les modÃ¨les.

### Ã‰volution d'une seule population en fonction du temps

La croissance d'une population (ou de sa densitÃ©) isolÃ©e en fonction du temps dÃ©pend des conditions qui lui offre son environnement. Dans le cas de la biomasse d'une culture Ã  croissance constante, le taux de croissance est toujours le mÃªme.

$$ \frac{d ğŸŒ¿ }{dt} = c $$

$$ \int_0^t c dt = \int_{ğŸŒ¿_0}^{ğŸŒ¿(t)} ~dğŸŒ¿ $$

$$ ct = ğŸŒ¿(t) - ğŸŒ¿_0$$

$$ ğŸŒ¿(t) = ğŸŒ¿_0 + ct $$

```{r}
par(mar=c(4, 4, 1, 1), ps=10)

y0 <- 2
c <- 2 # exprimÃ© en individu / pas de temps
times <- seq(0, 6, 0.1)
y <- y0 + c * times
plot(times, y, 'l', xlab="An",  ylab="Population", ylim=c(0, max(y)))
text(max(times), max(y), round(max(y)))
```

Dans le cas d'une population qui se reproduit, une formulation simple modÃ©lise une Ã©volution linÃ©aire associÃ©e Ã  un taux de natalitÃ© $n$ et un taux de mortalitÃ© $m$, oÃ¹ $r = n-m$ est le taux de croissance de la population d'une population de lapins ğŸ° en fonction du temps $t$.

$$ \frac{dğŸ°}{dt} = nğŸ° - mğŸ° = rğŸ° $$

$$ \int_0^t dt = \int_{ğŸ°_0}^{ğŸ°(t)} \frac{1}{rğŸ°} ~dğŸ° $$

$$ t = \frac{1}{r} ln(ğŸ°) \bigg\rvert_{ğŸ°_0}^{ğŸ°(t)} $$

$$ rt = ln \left( \frac{ğŸ°(t)}{ğŸ°_0} \right) $$

$$ ğŸ°(t) = ğŸ°_0 exp(rt) $$

La vitesse de croissance est constante pour une population constante, mais la croissance de la population est exponentielle Ã©tant donnÃ©e que chaque nouvel individu se reproduit.

```{r}
par(mar=c(4, 4, 1, 1), ps=10)

y0 <- 10
r <- 0.2 # exprimÃ© en individu / pas de temps
times <- seq(0, 10, 0.1)
y <- y0 * exp(r*times)
plot(times, y, 'l', xlab="An",  ylab="Lapin", ylim=c(0, max(y)))
text(max(times), max(y), round(max(y)))
```

De 10 lapins au dÃ©part, nous en avons un peu plus de 75 aprÃ¨s 10 ans... et prÃ¨s de 5 milliards aprÃ¨s 100 ans! En fait, la capacitÃ© de support d'une population Ã©tant gÃ©nÃ©ralement limitÃ©e, on peut supposer que le taux de natalitÃ© dÃ©croit et que le taux de mortalitÃ© croit linÃ©airement avec l'effectif.

$$ n(ğŸ°) = \alpha - \beta ğŸ° $$
$$ m(ğŸ°) = \gamma + \delta ğŸ° $$

On aura donc

$$ \frac{dğŸ°}{dt} = ğŸ° \left( \alpha - \beta ğŸ° \right) - ğŸ° \left( \gamma + \delta ğŸ° \right) = rğŸ° \left( 1 - \frac{ğŸ°}{K} \right) $$

oÃ¹ $r = \alpha - \gamma$ est l'ordonnÃ©e Ã  l'origine du taux de croissance (thÃ©orique, lorsque la population est nulle) et $K = \frac{\alpha-\gamma}{\beta + \delta}$ est la capacitÃ© limite du milieu de subsistance. On pourra s'aider d'un logiciel de calcul symbolique comme `sympy` ou [`maxima`](https://andrejv.github.io/wxmaxima/) pour en tirer une solution analytique. Mais Ã  ce point, nous utiliserons une approximation numÃ©rique. Nous utiliserons le module `deSolve`.

```{r}
library("deSolve")
```

`deSolve` demande de dÃ©finir les paramÃ¨tres de l'EDO ou du systÃ¨me d'EDO. Nous devons d'abord spÃ©cifier Ã  quels pas de temps notre EDO doit Ãªtre approximÃ©e. J'Ã©tends la plage de temps Ã  30 ans pour bien visualiser la courbe de croissance.

```{r}
times <- seq(0, 30, by = 0.5)
```

Les conditions initiales du systÃ¨me d'EDO sont aussi dÃ©finies dans un vecteur. La seule condition initiale de notre EDO est le nombre initial de lapin.

```{r}
y0 <- c(lapin = 10)
```

On dÃ©finira les paramÃ¨tres dans un vecteur `p`. Dans notre cas, nous avons $r$, le taux de croissance Ã  l'origine et $K$, la capacitÃ© de support de l'Ã©cosystÃ¨me. Il est prÃ©fÃ©rable de nommer les paramÃ¨tres du vecteur pour Ã©viter les erreurs.

```{r}
p <- c(r = 0.2, K = 40)
```

Enfin, une fonction dÃ©finit l'EDO avec, comme entrÃ©es, les pas de temps, les conditions initiales et les paramÃ¨tres. La sortie de la fonction est un vecteur des dÃ©rivÃ©es emboÃ®tÃ©s dans une liste (lisez le fichier d'aide de la fonction `ode` pour les dÃ©tails en lanÃ§ant `?ode`).

```{r}
model_logistic <- function(t, y, p) {
  lapin <- y[1]
  dlapin_dt <- p[1] * lapin * (1 - lapin/p[2])
  return(list(c(dlapin_dt)))
}
```

Une fois que les pas de temps, les conditions initiales, les paramÃ¨tres et le modÃ¨le sont dÃ©finis, on les spÃ©cifie comme arguments dans la fonction `ode`. La sortie de la fonction `ode` est une matrice dont la premiÃ¨re colonne comprend les pas de temps imposÃ©s, et les autres colonnes sont les dÃ©rivÃ©es spÃ©cifiÃ©es Ã  la sortie de la fonction `ode`.


```{r}
lapin_t <- ode(y = y0, times = times, model_logistic, p)
head(lapin_t)
```

```{r}
par(mar=c(4, 4, 1, 1), ps=10)
plot(lapin_t[, 1], lapin_t[, 2], type='l', xlab="An",  ylab="Lapin", ylim=c(0, max(lapin_t[, 2])))
```

**Exercice**. Que ce passerait-il si le taux de croissance Ã©tait nÃ©gatif? Profitez-en pour changer les paramÃ¨tres `r` et `K`.

**Exercice**. D'autres formulations existent pour exprimer des taux de croissance (Gompertz, Allee, etc.). En outre la formulation de Gompertz s'Ã©crit comme suit.

$$ \frac{dğŸ°}{dt} = rğŸ° \left( ln \frac{K}{ğŸ°} \right) $$

Entrer cet EDO dans `R` avec `deSolve`.

### Population exploitÃ©e

L'exploitation d'une population peut Ãªtre effectuÃ©e de diffÃ©rentes maniÃ¨res. D'abord, le prÃ©lÃ¨vement peut Ãªtre effectuÃ© de maniÃ¨re constante, par exemple dans un Ã©levage ou par la chasse ou la cueillette. Ajoutons un prÃ©lÃ¨vement constant dans une courbe de croissance logistique.

$$ \frac{dğŸ°}{dt} = rğŸ° \left( 1 - \frac{ğŸ°}{K} \right) - Q $$

oÃ¹ $Q$ est le quota, ou le prÃ©lÃ¨vement constant.

On pourra aussi effectuer un prÃ©lÃ¨vement proportionnel Ã  la population.

$$ \frac{dğŸ°}{dt} = rğŸ° \left( 1 - \frac{ğŸ°}{K} \right) - EğŸ° $$

oÃ¹ $E$ est l'effort d'exploitation.

Ou bien effectuer une sÃ©rie de prÃ©lÃ¨vement ponctuels, comme la rÃ©colte de plantes fourragÃ¨res.

$$ \frac{dğŸŒ¿}{dt} = c - \left[ ğŸŒ¿ - \gamma \right] \bigg\rvert_{t=a, b, c, d, e, ...} $$

oÃ¹ $\gamma$ est le reste de la biomasse aprÃ¨s la rÃ©colte et $t=a, b, c, d, e, ...$ sont les pas de temps oÃ¹ le bloc entre les crochets est actif, c'est-Ã -dire la pÃ©riode de rÃ©colte. La solution analytique d'une culture Ã  croissance constante est plutÃ´t facile Ã  dÃ©duire.

Les fonctions de prÃ©lÃ¨vement peuvent Ãªtre modulÃ©es Ã  votre guise.

Prenons pour l'exemple un prÃ©lÃ¨vement constant et une croissance logistique.

```{r}
p <- c(r = 0.2, K = 40, Q = 1)

model_logistic_expl <- function(t, y, p) {
  lapin <- y[1]
  dlapin_dt <- p[1] * lapin * (1 - lapin/p[2]) - p[3]
  return(list(c(dlapin_dt)))
}

lapin_t <- ode(y = y0, times = times, model_logistic_expl, p)
par(mar=c(4, 4, 1, 1), ps=10)
plot(lapin_t[, 1], lapin_t[, 2], type='l', xlab="An",  ylab="Lapin", ylim=c(0, max(lapin_t[, 2])))
```

**Exercice**. ModÃ©liser avec un prÃ©lÃ¨vement proportionnel.

L'**exploitation ponctuelle**, comme la rÃ©colte ou l'administration d'une sÃ©rie de traitements, implique l'utilisation d'approches intermittentes. `deSolve` ignore les changements dans les variables d'Ã©tat (`y`) tels que dÃ©finis dans les dÃ©rivÃ©s. Pour ce faire, nous devons avoir recours Ã  des Ã©vÃ¨nements dans le jargon de `deSolve`. Ces Ã©vÃ¨nements doivent Ãªtre spÃ©cifiÃ©s dans un `data.frame` ou une liste. Il est difficile de trouver un exemple gÃ©nÃ©rique pour modÃ©liser des Ã©vÃ¨nements. Pour en savoir davantage, je vous invite donc Ã  consulter la fiche d'aide `?events`.

Dans notre cas, nous allons modÃ©liser une rÃ©colte de plantes fourragÃ¨res. La rÃ©colte est dÃ©clenchÃ©e lorsque le rendement atteint 2 t/ha, et laisser 0.3 t/ha au sol pour assurer le renouvellement pour les coupes subsÃ©quentes. DÃ©finissons d'abord les entrÃ©es du modÃ¨les.

```{r}
times <- seq(0, 120, 0.1)
p <- c(r = 0.1, K = 2.5)
y0 <- c(champ = 0.1)
```

Nous devons dÃ©finir une fonction root, dont la sortie est une valeur qui dÃ©clenchera un Ã©vÃ¨nement lorsque la valeur sera nulle. Dans notre cas, la valeur correspond simplement au rendement moins 2, la quantitÃ© au champ y[1]. Notez que d'autres stratÃ©gies peuvent Ãªtre utilisÃ©es pour dÃ©clencher une rÃ©colte, par exemple le pourcentage de floraison qui demanderait des simulations plus poussÃ©es.

```{r}
recolte_root <- function(t, y, p) y[1]-2
```


Puis, lorsque la fonction root est dÃ©clenchÃ©e, lâ€™Ã©vÃ¨nement ramÃ¨ne la quantitÃ© au champs Ã  1 t/ha, une quantitÃ© qui permet de relancer la croissance.

```{r}
recolte_event <- function(t, y, p) {
    y[1] <- 0.3
    return(y)
}
```

La fonction du modÃ¨le est telle qu'utilisÃ©e auparavant: une fonction logistique.

```{r}
recolte <- function(t, y, p) {
    champ <- y[1]
    dchamp_dt <- p[1] * champ * (1 - champ/p[2])
    return(list(c(dchamp_dt)))
}
```

La fonction `ode` est lancÃ©e en entrant les fonction `root` et `events`.

```{r}
out <- ode(times = times, y = y0, func = recolte, parms = p,
           rootfun = recolte_root,
           events = list(func = recolte_event, root = TRUE),
          method="impAdams")
plot(out)
```

Nous pourrons organiser deux rÃ©coltes de 1.7 t/ha et une de 2 t/ha pour terminer la saison.

**Exercice**. Qu'adviendrait-il si vous laissiez 0.15 t/ha au champ au lieu de 0.3? Ou si vous laissiez 1 t/ha? Ou si vous dÃ©clenchiez une rÃ©colte Ã  2.3 t/ha?

**DÃ©fi**. Pouvez-vous modÃ©liser l'ensilage?

### Interactions biologiques

Les interactions biologiques entre deux espÃ¨ces Ã  un stade de croissance dÃ©fini peuvent prendre diffÃ©rentes formes, du mutualisme (les deux espÃ¨ces bÃ©nÃ©ficient de la relation) Ã  la compÃ©tition (les deux espÃ¨ces se nuisent) en passant par la prÃ©dation ou le parasitisme (une espÃ¨ce bÃ©nÃ©ficie de l'autre en lui nuisant) ou le neutralisme (aucun effet). Ces effets sont dÃ©crits dans [Pringle (2016)](https://doi.org/10.1371/journal.pbio.2000891) en un tableau synthÃ¨se.


<center>
<img src="images/13_journal.pbio.2000891.g001.png" width=600px>
Source: Pringle, E.G. 2016. Orienting the Interaction Compass: Resource Availability as a Major Driver of Context Dependence. Plos Biology. https://doi.org/10.1371/journal.pbio.2000891
</center>

Ces interactions peuvent Ãªtre dÃ©crite mathÃ©matiquement dans des systÃ¨mes d'EDO, ou EDO couplÃ©es. Le cas d'Ã©tude le plus courant reprend le systÃ¨me d'Ã©quation prÃ©dateur-proie de **Lotka-Volterra**, deux auteurs ayant dÃ©veloppÃ© de maniÃ¨re indÃ©pendante des Ã©quations similaires respectivement en 1925 et 1926.

Les Ã©quations de Lotka-Volterra supposent une croissance illimitÃ©e des deux espÃ¨ces: les proies ğŸ° se reproduisent par elles-mÃªmes ($\alpha ğŸ°$), tandis que les prÃ©dateurs ğŸ¦Š croissent selon la disponibilitÃ© des proies ($\delta ğŸ°ğŸ¦Š$). Ã€ l'inverse, la mortalitÃ© des proies dÃ©pend du nombre de prÃ©dateurs ($- \beta ğŸ°ğŸ¦Š$), mais la mortalitÃ© des prÃ©dateurs est indÃ©pendante des proies ($- \gamma ğŸ¦Š$). On obtient ainsi un systÃ¨me d'Ã©quation.

$$\frac{dğŸ°}{dt} = \alpha ğŸ° - \beta ğŸ°ğŸ¦Š = ğŸ° \left( \alpha - \beta ğŸ¦Š \right)$$

$$\frac{dğŸ¦Š}{dt} = \delta ğŸ°ğŸ¦Š - \gamma ğŸ¦Š = ğŸ¦Š \left( \delta ğŸ° - \gamma \right) $$

Ã€ l'Ã©quilibre de ğŸ°, c'est-Ã -dire oÃ¹ $\frac{dğŸ°}{dt} = 0$, on retrouve $ğŸ°=0$ ou $ğŸ¦Š = \frac{\alpha}{\beta}$. De mÃªme, Ã  l'Ã©quilibre de ğŸ¦Š, on retrouve $ğŸ¦Š=0$ ou $ğŸ° = \frac{\gamma}{\delta}$. En termes mathÃ©matiques, ces Ã©quilibre sont des isoclines, des points d'inflexion dans le systÃ¨me d'EDO.

Nous allons rÃ©soudre les Ã©quations de Lotka-Volterra avec `deSolve`. Rappelons-nous que nous devons dÃ©finir des pas de temps oÃ¹ approximer les populations (`times`), des conditions initiales (`y0`) et des paramÃ¨tres (`p`).

```{r}
times <- seq(0, 30, by = 0.1)

y0 <- c(lapin = 3, renard = 1)

p <- c(alpha = 2, # taux de croissance des lapins (naissance - mortalitÃ©, 1/an)
      beta = 0.8, # taux de prÃ©dation des lapins (renard / an)
      delta = 0.1, # taux de conversion lors de la prÃ©dation (lapin / renard)
      gamma = 0.2) # mortalitÃ© naturelle des renards (1/an)
```

On peut calculer d'emblÃ©e les isoclines.

```{r}
lapin_iso <- p[4]/p[3]
renard_iso <- p[1]/p[2]
```

Nous devons ensuite crÃ©er notre modÃ¨le.

```{r}
modele_LV <- function(t, y, p) {
  lapin = y[1]
  renard = y[2]
  dlapin_dt = p[1] * lapin - p[2] * lapin * renard
  drenard_dt = p[3] * lapin * renard - p[4] * renard
  return(list(c(dlapin_dt, drenard_dt)))
}
```

LanÃ§ons l'approximation.

```{r}
effectifs_t = ode(y = y0, times = times, modele_LV, p)
head(effectifs_t)
```

```{r}
par(mar=c(4, 4, 1, 1), ps=10)

plot(effectifs_t[, 1], effectifs_t[, 2], type = 'l', ylim = c(0, max(effectifs_t[, 2])),
     xlab = 'Temps', ylab = "Nombre d'individus") # lapins
lines(effectifs_t[, 1], effectifs_t[, 3], col = 'red')

legend(x=4, y=12, legend=c("Lapins", "Renards"), col=c("black", "red"),
       lty=c(1, 1), cex=1.2)
```

Lorsque la population de lapins croit, celle des renards croit Ã  retardement jusqu'Ã  ce que la population de lapin diminue jusqu'Ã  Ãªtre presque Ã©teinte. Dans ces conditions, la population de renard ne peut plus Ãªtre soutenue, et dÃ©croit, ce qui en retour donne l'opportunitÃ© de la population de lapins de resurgir.

```{r}
par(mar=c(4, 4, 1, 1), ps=10)

plot(effectifs_t[, 2], effectifs_t[, 3], type = 'l', xlab = "Nombre lapins",
     ylab= "Nombre de renards",
     xlim = c(0, max(effectifs_t[, 2])), ylim = c(0, max(effectifs_t[, 3])))

# isoclines
abline(v=lapin_iso, lty=2, col="black")
abline(h=renard_iso, lty=2, col="red")
points(lapin_iso, renard_iso)

# condition initiale
points(y0[1], y0[2], pch = 16)
```

Les conditions initiales sont responsables de l'amplitude des cycles. En faisant les faisant varier et en portant graphiquement les vecteurs de flux, on peut mieux apprÃ©cier l'importance des isoclines, qui sÃ©parent la direction que prend la relation entre deux espÃ¨ces.

```{r}
effectifs_i <- list()
lapin_0 <- 1:30
for (i in 1:length(lapin_0)) {
    y0[1] <- lapin_0[i]
    effectifs_i[[i]] <- ode(y = y0, times = times, modele_LV, p)
    offsets <- effectifs_i[[i]][-1, -1] - effectifs_i[[i]][-nrow(effectifs_i[[i]]), -1]
    colnames(offsets) <- c("d_lapin", "d_renard")
    effectifs_i[[i]] <- cbind(effectifs_i[[i]][-1, ], offsets)
}
effectifs_df <- do.call(rbind.data.frame, effectifs_i)
```

```{r}
library("plotrix")

plot(effectifs_df[, 2], effectifs_df[, 3], type = 'n', xlab = "Nombre lapins",
     ylab= "Nombre de renards",
     xlim = c(0, max(effectifs_df[, 2])), ylim = c(0, max(effectifs_df[, 3])))

# isoclines
abline(v=lapin_iso, lty=2, col="black")
abline(h=renard_iso, lty=2, col="red")
points(lapin_iso, renard_iso)

vectorField(u=effectifs_df[, 4], v=effectifs_df[, 5],
            xpos=effectifs_df[, 2], ypos=effectifs_df[, 3],
            scale=0.1, headspan=0.05,
            vecspec="lonlat")
```

Nous avons modÃ©lisÃ© une relation biologique de prÃ©dation. Il existe dans la littÃ©rature une panoplie de modÃ¨les d'EDO pour dÃ©crire les relations biologiques, qui peuvent Ãªtre modÃ©lisÃ©s entre plusieurs espÃ¨ces pour crÃ©er des rÃ©seaux trophiques complexes. Toutefois, la difficultÃ© de collecter des donnÃ©es en quantitÃ© et en qualitÃ© suffisante rendent ces modÃ¨les difficiles Ã  apprÃ©hender.

**Exercice**. Quâ€™adviendrait-il des populations si l'on prenait plutÃ´t un profil de croissance logistique chez les lapins?

$$\frac{dğŸ°}{dt} = rğŸ° \left( 1-\frac{x}{K} \right) - \beta ğŸ°ğŸ¦Š $$

$$\frac{dğŸ¦Š}{dt} = \delta ğŸ°ğŸ¦Š - \gamma ğŸ¦Š $$

**Exercice**. ModÃ©liser une compÃ©tition interspÃ©cifique oÃ¹ chaque population croit de maniÃ¨re logistique.

$$\frac{dğŸ}{dt} = r_1 ğŸ \left( 1-\frac{ğŸ}{K_1} -\alpha \frac{ğŸ€}{K_1} \right) $$

$$\frac{dğŸ}{dt} = r_2 ğŸ€ \left( 1-\frac{ğŸ€}{K_2} -\beta \frac{ğŸ}{K_2} \right) $$

oÃ¹ $r_1$ et $r_2$ sont les taux de croissances respectifs des ğŸ et des ğŸ€, ainsi que $K_1$ et que $K_2$ sont les capacitÃ©s de support des ğŸ et des ğŸ€. Le coefficient $\alpha$ dÃ©crit l'ampleur de la compÃ©tition de ğŸ€ sur ğŸ et le coefficient $\beta$ dÃ©crit l'ampleur de la compÃ©tition de ğŸ sur ğŸ€ ($\alpha$ et $\beta$ sont >= 0).

**Exercice**. Les interactions biologiques forment une bonne introduction aux systÃ¨mes d'Ã©quations diffÃ©rentielles ordinaires. On fait nÃ©anmoins souvent rÃ©fÃ©rence aux Ã©quations de [Lorenz (1963)](https://journals.ametsoc.org/doi/abs/10.1175/1520-0469%281963%29020%3C0130:DNF%3E2.0.CO;2), qui a dÃ©veloppÃ© un systÃ¨me d'EDO chaotique depuis trois Ã©quations,

$$ X' = aX + YZ, $$
$$ Y' = b \left(Y-Z\right), $$
$$ Z' =  -XY + cY - Z, $$

oÃ¹ $X$ est la tempÃ©rature horizontale, $Y$ est la tempÃ©rature verticale, $Z$ est le flux de chaleur convectif, et oÃ¹ l'on retrouve les paramÃ¨tres $a = -8/3$, $b=-10$ et $c=28$.

RÃ©soudre les Ã©quations de Lorents avec `deSolve`. Porter graphiquement les relations entre X, Y et Z.

## Les Ã©quations diffÃ©rentielles partielles en modÃ©lisation Ã©cologique

Contrairement aux EDO, la solution des Ã©quations diffÃ©rentielle partielles (EDP) dÃ©pend de plus d'une variable indÃ©pendante. Typiquement, elles dÃ©pendent de coordonnÃ©es spatiales. Elles peuvent aussi dÃ©pendre du temps. Dans cette section, nous allons explorer les rÃ©gimes permanents, c'est-Ã -dire indÃ©pendants du temps, en utilisant la mÃ©thode des diffÃ©rences finies. Nous allons aussi explorer les problÃ¨mes transitoires, qui eux dÃ©pendent du temps, en utilisant la mÃ©thode des lignes.

Ã€ venir...
