[
["chapitre-ordination.html", "8 Association, partitionnement et ordination 8.1 Espaces dâ€™analyse 8.2 Analyse dâ€™association 8.3 Partitionnement 8.4 Ordination", " 8 Association, partitionnement et ordination ï¸Â Objectifs spÃ©cifiques: Ã€ la fin de ce chapitre, vous serez en mesure dâ€™effectuer des calculs permettant de mesurer des diffÃ©rence entre des observations, des groupes dâ€™observation ou des variables observÃ©es serez en mesure dâ€™effection des analyses de partitionnement hiÃ©rarchiques et non-hiÃ©rarchiques serez en mesure dâ€™effectuer des calculs dâ€™ordination Ã  lâ€™aide des techniques de rÃ©duction dâ€™axe communes: analyse en composante principale, analyse discriminante linÃ©aire, lâ€™analyse de correspondance, lâ€™analyse factorielle, lâ€™analyse en coordonnÃ©es principales et lâ€™analyse de redondance. Les donnÃ©es Ã©cologiques incluent gÃ©nÃ©ralement plusieurs variables qui doivent Ãªtre analysÃ©es conjointement. Les techniques pour lâ€™analyse multivariÃ©e de donnÃ©es Ã©cologiques ont grandi en nombre et en complexitÃ©, laissant Ã©merger lâ€™Ã©cologie numÃ©rique, un nouveau domaine dâ€™Ã©tude scientifique initiÃ© par Pierre Legendre et Louis Legendre dont lâ€™ouvrage Numerical Ecology, aujourdâ€™hui Ã  sa troisiÃ¨me Ã©dition, reste un incontournable pour qui sâ€™intÃ©resse aux mathÃ©matiques sous-jacentes au domaine. Pour la rÃ©daction de ces notes, câ€™est toutefois le livre Numerical ecology with R, Ã©crit par Borcard et al. (2011) pour offrir un guide Ã  qui voudrait une approche plus appliquÃ©e. Lâ€™Ã©cologie numÃ©rique sera effleurÃ©e dans ce chapitre, qui introduit Ã  trois concepts. Les associations permettent de quantifier la ressemblance ou la diffÃ©rence entre deux observation (Ã©chantillons) ou variables (descripteurs). Lorsque lâ€™on a plus de deux variables ou plus de deux site, nous obtenons des matrices dâ€™association. Le partitionnement permet de regrouper des observations ou des variables selon des mÃ©triques dâ€™association. Lâ€™ordination vise par lâ€™intermÃ©diaire de techniques de rÃ©duction dâ€™axe Ã  mettre de lâ€™ordre dans des donnÃ©es dont le nombre Ã©levÃ© de variables peut amener Ã  des difficultÃ©s dâ€™apprÃ©ciation et dâ€™interprÃ©taion. library(&quot;tidyverse&quot;) ## â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.2.1 â”€â”€ ## âœ” ggplot2 3.1.0 âœ” purrr 0.3.0 ## âœ” tibble 2.0.1 âœ” dplyr 0.8.0 ## âœ” tidyr 0.8.2 âœ” stringr 1.4.0 ## âœ” readr 1.3.1 âœ” forcats 0.3.0 ## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€ ## âœ– dplyr::filter() masks stats::filter() ## âœ– dplyr::lag() masks stats::lag() 8.1 Espaces dâ€™analyse 8.1.1 Abondance et occurence Lâ€™abondance est le dÃ©compte dâ€™espÃ¨ces observÃ©es, tandis que lâ€™occurence est la prÃ©sence ou lâ€™absence dâ€™une espÃ¨ce. Le tableau suivant contient des donnÃ©es dâ€™abondance. abundance &lt;- tibble(&#39;Bruant familier&#39; = c(1, 0, 0, 3), &#39;Citelle Ã  poitrine rousse&#39; = c(1, 0, 0, 0), &#39;Colibri Ã  gorge rubis&#39; = c(0, 1, 0, 0), &#39;Geai bleu&#39; = c(3, 2, 0, 0), &#39;Bruant chanteur&#39; = c(1, 0, 5, 2), &#39;Chardonneret&#39; = c(0, 9, 6, 0), &#39;Bruant Ã  gorge blanche&#39; = c(1, 0, 0, 0), &#39;MÃ©sange Ã  tÃªte noire&#39; = c(20, 1, 1, 0), &#39;Jaseur borÃ©al&#39; = c(66, 0, 0, 0)) Ce tableau peut Ãªtre rapidement transformÃ© en donnÃ©es dâ€™occurence, qui ne comprennent que lâ€™information boolÃ©enne de prÃ©sence (notÃ© 1) et dâ€™absence (notÃ© 0). occurence &lt;- abundance %&gt;% transmute_all(funs(if_else(. &gt; 0, 1, 0))) ## Warning: funs() is soft deprecated as of dplyr 0.8.0 ## please use list() instead ## ## # Before: ## funs(name = f(.) ## ## # After: ## list(name = ~f(.)) ## This warning is displayed once per session. Lâ€™espace des espÃ¨ces (ou des variables ou descripteurs) est celui oÃ¹ les espÃ¨ces forment les axes et oÃ¹ les sites sont positionnÃ©s dans cet espace. Il sâ€™agit dâ€™une perspective en mode R, qui permet principalement dâ€™identifier quels espÃ¨ces se retrouvent plus courrament ensemble. abundance %&gt;% select(&quot;Bruant chanteur&quot;, &quot;Chardonneret&quot;, &quot;MÃ©sange Ã  tÃªte noire&quot;) ## # A tibble: 4 x 3 ## `Bruant chanteur` Chardonneret `MÃ©sange Ã  tÃªte noire` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0 20 ## 2 0 9 1 ## 3 5 6 1 ## 4 2 0 0 Dans lâ€™espace des sites (ou les Ã©chantillons ou objets), on transpose la matrice dâ€™abondance. On passe ici en mode Q, oÃ¹ chaque point est une espÃ¨ce, et oÃ¹ lâ€™on peut observer quels Ã©chantillons sont similaires. abundance %&gt;% .[c(1, 2, 3), ] %&gt;% t(.) ## [,1] [,2] [,3] ## Bruant familier 1 0 0 ## Citelle Ã  poitrine rousse 1 0 0 ## Colibri Ã  gorge rubis 0 1 0 ## Geai bleu 3 2 0 ## Bruant chanteur 1 0 5 ## Chardonneret 0 9 6 ## Bruant Ã  gorge blanche 1 0 0 ## MÃ©sange Ã  tÃªte noire 20 1 1 ## Jaseur borÃ©al 66 0 0 8.1.2 Environnement Lâ€™espace de lâ€™environnement comprend souvent un autre tableau contenant lâ€™information sur lâ€™environnement oÃ¹ se trouve les espÃ¨ces: les coordonnÃ©es et lâ€™Ã©lÃ©vation, la pente, le pH du sol, la pluviomÃ©trie, etc. 8.2 Analyse dâ€™association Nous utiliserons le terme association come une mesure pour quantifier la ressemblance ou la diffÃ©rence entre deux objets (Ã©chantillons) ou variables (descripteurs). Alors que la corrÃ©lation et la covariance sont des mesures dâ€™association entre des variables (analyse en mode R), la similaritÃ© et la distance sont deux types de une mesure dâ€™association entre des objets (analyse en mode Q). Une distance de 0 est mesurÃ©e chez deux objets identiques. La distance augmente au fur et Ã  mesure que les objets sont dissociÃ©s. Une similaritÃ© ayant une valeur de 0 indique aucune association, tandis quâ€™une valeur de 1 indique une association parfaite. Ã€ lâ€™opposÃ©, la dissimilaritÃ© est Ã©gale Ã  1-similaritÃ©. La distance peut Ãªtre liÃ©e Ã  la similaritÃ© par la relation: \\[distance=\\sqrt{1-similaritÃ©}\\] ou \\[distance=\\sqrt{dissimilaritÃ©}\\] La racine carrÃ©e permet, pour certains indices de similaritÃ©, dâ€™obtenir des propriÃ©tÃ©s euclÃ©diennes. Pour plus de dÃ©tails, voyez le tableau 7.2 de Legendre et Legendre (2012). Les matrices dâ€™association sont gÃ©nÃ©ralement prÃ©sentÃ©es comme des matrices carrÃ©es, dont les dimensions sont Ã©gales au nombre dâ€™objets (mode Q) ou de vrariables (mode R) dans le tableau. Chaque Ã©lÃ©ment (â€œcelluleâ€) de la matrice est un indice dâ€™association entre un objet (ou une variable) et un autre. Ainsi, la diagonale de la matrice est un vecteur nul (distance ou dissimilaritÃ©) ou unitaire (similaritÃ©), car elle correspond Ã  lâ€™association entre un objet et lui-mÃªme. Puisque lâ€™association entre A et B est la mÃªme quâ€™entre B et A, et puisque la diagonale retourne une valeur convenue, il est possible dâ€™exprimer une matrice dâ€™association en mode â€œcompactâ€, sous forme de vecteur. Le vecteur dâ€™association entre des objets A, B et C contiendra toute lâ€™information nÃ©cessaire en un vecteur de trois chiffres, [AB, AC, BC], plutÃ´t quâ€™une matrice de dimension \\(3 \\times 3\\). Lâ€™impact sur la mÃ©moire vive peut Ãªtre considÃ©rable pour les calculs comprenant de nombreuses dimensions. En R, les calculs de similaritÃ© et de distances peuvent Ãªtre effectuÃ©s avec le module vegan. La fonction vegdist permet de calculer les indices dâ€™association en forme carrÃ©e. Nous verons plus tard les mÃ©thodes de mesure de similaritÃ© et de distance plus loin. Pour lâ€™instant, utilisons la mÃ©thode de Jaccard pour une dÃ©monstration sur des donnÃ©es dâ€™occurence. library(&quot;vegan&quot;) ## Loading required package: permute ## Loading required package: lattice ## This is vegan 2.5-4 vegdist(occurence, method = &quot;jaccard&quot;, diag = TRUE, upper = TRUE) ## 1 2 3 4 ## 1 0.0000000 0.7777778 0.7500000 0.7142857 ## 2 0.7777778 0.0000000 0.6000000 1.0000000 ## 3 0.7500000 0.6000000 0.0000000 0.7500000 ## 4 0.7142857 1.0000000 0.7500000 0.0000000 Remarquez que vegdist retourne une matrice dont la diagonale est de 0 (on lâ€™affiche en spÃ©cifiant diag = TRUE). La diagonale est lâ€™association dâ€™un objet avec lui-mÃªme. Or la similaritÃ© dâ€™un objet avec lui-mÃªme devrait Ãªtre de 1! En fait, par convention vegdist retourne des dissimilaritÃ©s, non pas des similaritÃ©s. La matrice de distance serait donc calculÃ©e en extrayant la racine carrÃ©e des Ã©lÃ©ments de la matrice de dissimilaritÃ©: dissimilarity &lt;- vegdist(occurence, method = &quot;jaccard&quot;, diag = TRUE, upper = TRUE) distance &lt;- sqrt(dissimilarity) distance ## 1 2 3 4 ## 1 0.0000000 0.8819171 0.8660254 0.8451543 ## 2 0.8819171 0.0000000 0.7745967 1.0000000 ## 3 0.8660254 0.7745967 0.0000000 0.8660254 ## 4 0.8451543 1.0000000 0.8660254 0.0000000 Dans le chapitre sur lâ€™analyse compositionnelle, nous avons abordÃ© les significations diffÃ©rentes que peuvent prendre le zÃ©ro. Lâ€™information fournie par un zÃ©ro peut Ãªtre diffÃ©rente selon les circonstances. Dans le cas dâ€™une variable continue, un zÃ©ro signifie gÃ©nÃ©ralement une mesure sous le seuil de dÃ©tection. Deux tissus dont la concentration en cuivre est nulle ont une afinitÃ© sous la perspective de la concentration en cuivre. Dans le cas de mesures dâ€™abondance (dÃ©compte) ou dâ€™occurence (prÃ©sence-absence), on pourra dÃ©crire comme similaires deux niches Ã©cologiques oÃ¹ lâ€™on retrouve une espÃ¨ce en particulier. Mais deux sites oÃ¹ lâ€™on de retouve pas dâ€™ours polaires ne correspondent pas nÃ©cessairement Ã  des niches similaires! En effet, il peut exister de nombreuses raisons Ã©cologiques et mÃ©thodologiques pour lesquelles lâ€™espÃ¨ces ou les espÃ¨ces nâ€™ont pas Ã©tÃ© observÃ©es. Câ€™est le problÃ¨me des double-zÃ©ros (espÃ¨ces non observÃ©es Ã  deux sites), problÃ¨me qui est amplifiÃ© avec les grilles comprenant des espÃ¨ces rares. La ressemblance entre des objets comprenant des donnÃ©es continues devrait Ãªtre calculÃ©e grÃ¢ce Ã  des indicateurs symÃ©triques. Inversement, les affinitÃ©s entre les objets dÃ©crits par des donnÃ©es dâ€™abondance ou dâ€™occurence susceptibles de gÃ©nÃ©rer des problÃ¨mes de double-zÃ©ros devraient Ãªtre Ã©valuÃ©es grÃ¢ce Ã  des indicateurs asymÃ©triques. Un dÃ©fi supplÃ©mentaire arrive lorsque les donnÃ©es sont de type mixte. Nous utiliserons la convention de scipy et nous calculerons la dissimilaritÃ©, non pas la similaritÃ©. Les mesures de dissimilaritÃ© sont calculÃ©es sur des donnÃ©es dâ€™abondance ou des donnÃ©es dâ€™occurence. Notons quâ€™il existe beaucoup de confusion dans la littÃ©rature sur la maniÃ¨re de nommer les dissimilaritÃ©s (ce qui nâ€™est pas le cas des distances, dont les noms sont reconnus). Dans les sections suivantes, nous noterons la dissimilaritÃ© avec un \\(d\\) minuscule et la distance avec un \\(D\\) majuscule. 8.2.1 Association entre objets (mode Q) 8.2.1.1 Objets: Abondance La dissimilaritÃ© de Bray-Curtis est asymÃ©trique. Elle est aussi appelÃ©e lâ€™indice de Steinhaus, de Czekanowski ou de SÃ¸rensen. Il est important de sâ€™assurer de bien sâ€™entendre la mÃ©thode Ã  laquelle on fait rÃ©fÃ©rence. Lâ€™Ã©quation enlÃ¨ve toute ambiguitÃ©. La dissimilaritÃ© de Bray-Curtis entre les points A et B est calculÃ©e comme suit. \\[d_{AB} = \\frac {\\sum \\left| A_{i} - B_{i} \\right| }{\\sum \\left(A_{i}+B_{i}\\right)}\\] Utilisons vegdist pour gÃ©nÃ©rer les matrices dâ€™association. Le format â€œlisteâ€ de R est pratique pour enregistrer la collection dâ€™objets, dont les matrice dâ€™association que nous allons crÃ©er dans cette section. associations_abund &lt;- list() associations_abund[[&#39;BrayCurtis&#39;]] &lt;- vegdist(abundance, method = &quot;bray&quot;) associations_abund[[&#39;BrayCurtis&#39;]] ## 1 2 3 ## 2 0.9433962 ## 3 0.9619048 0.4400000 ## 4 0.9591837 1.0000000 0.7647059 La dissimilaritÃ© de Bray-Curtis est souvent utilisÃ©e dans la littÃ©rature. Toutefois, la version originale de Bray-Curtis nâ€™est pas tout Ã  fait mÃ©trique (semimÃ©trique). ConsÃ©quemment, la dissimilaritÃ© de Ruzicka (une variante de la dissimilaritÃ© de Jaccard pour les donnÃ©es dâ€™abondance) est mÃ©trique, et devrait probablement Ãªtre prÃ©fÃ©rÃ© Ã  Bary-Curtis (Oksanen, 2006). \\[d_{AB, Ruzicka} = \\frac { 2 \\times d_{AB, Bray-Curtis} }{1 + d_{AB, Bray-Curtis}}\\] associations_abund[[&#39;Ruzicka&#39;]] &lt;- associations_abund[[&#39;BrayCurtis&#39;]] * 2 / (1 + associations_abund[[&#39;BrayCurtis&#39;]]) La dissimilaritÃ© de Kulczynski (aussi Ã©crit Kulsinski) est asymÃ©trique et semimÃ©trique, tout comme celle de Bray-Curtis. Elle est calculÃ©e comme suit. \\[d_{AB} = 1-\\frac{1}{2} \\times \\left[ \\frac{\\sum min(A_i, B_i)}{\\sum A_i} + \\frac{\\sum min(A_i, B_i)}{\\sum B_i} \\right]\\] associations_abund[[&#39;Kulczynski&#39;]] &lt;- vegdist(abundance, method = &quot;kulczynski&quot;) Une approche commune pour mesurer lâ€™association entre sites dÃ©crits par des donnÃ©es dâ€™abondance est la distance de Hellinger. Notez quâ€™il sâ€™agit ici dâ€™une distance, non pas dâ€™une dissimilaritÃ©. Pour lâ€™obtenir, on doit dâ€™abord diviser chaque donnÃ©e dâ€™abondance par lâ€™abondance totale pour chaque site pour obtenir les espÃ¨ces en tant que proportions, puis on extrait la racine carrÃ©e de chaque Ã©lÃ©ment. Enfin, on calcule la distance euclidienne entre les proportions de chaque site. Pour rappel, une distance euclidienne est la gÃ©nÃ©ralisation en plusieurs dimensions du thÃ©orÃ¨me de Pythagore, \\(c = \\sqrt{a^2 + b^2}\\). \\[D_{AB} = \\sqrt {\\sum \\left( \\frac{A_i}{\\sum A_i} - \\frac{B_i}{\\sum B_i} \\right)^2}\\] ğŸ˜±Â Attention La distance dâ€™Hellinger hÃ©rite des biais liÃ©es aux donnÃ©es compositionnelles. Elle peut Ãªtre substitiÃ©e par une matrice de distances dâ€™Aitchison. associations_abund[[&#39;Hellinger&#39;]] &lt;- dist(decostand(abundance, method=&quot;hellinger&quot;)) Toute comme la distance dâ€™Hellinger, la distance de chord est calculÃ©e par une distance euclidienne sur des donnÃ©es dâ€™abondance transformÃ©es de sorte que chaque ligne ait une longueur (norme) de 1. associations_abund[[&#39;Chord&#39;]] &lt;- dist(decostand(abundance, method=&quot;normalize&quot;)) La mÃ©trique du chi-carrÃ©, ou \\(\\chi\\)-carrÃ©, ou chi-square, donne davantage de poids aux espÃ¨ces rares quâ€™aux espÃ¨ces communes. Son utilisation est recommandÃ©e lorsque les espÃ¨ces rares sont de bons indicateurs de conditions Ã©cologiques particuliÃ¨res (Legendre et Legendre, 2012, p.Â 308). \\[ d_{AB} = \\sqrt{\\sum _j \\frac{1}{\\sum y_j} \\left( \\frac{A_j}{\\sum A} - \\frac{B_j}{\\sum B} \\right)^2 } \\] La mÃ©trique peut Ãªtre transformÃ©e en distance en la multipliant par la racine carrÃ©e de la somme totale des espÃ¨ces dans la matric dâ€™abondance (\\(X\\)). \\[ D_{AB} = \\sqrt{\\sum X} \\times d_{AB} \\] associations_abund[[&#39;ChiSquare&#39;]] &lt;- dist(decostand(abundance, method=&quot;chi.square&quot;)) Une manniÃ¨re visuellement plus intÃ©ressante de prÃ©senter une matrice dâ€™association est un graphique de type heatmap. associations_abund_df &lt;- list() for (i in 1:length(associations_abund)) { associations_abund_df[[i]] &lt;- data.frame(as.matrix(associations_abund[[i]])) colnames(associations_abund_df[[i]]) &lt;- rownames(associations_abund_df[[i]]) associations_abund_df[[i]]$row &lt;- rownames(associations_abund_df[[i]]) associations_abund_df[[i]] &lt;- associations_abund_df[[i]] %&gt;% gather(key=row) associations_abund_df[[i]]$column = rep(1:4, 4) associations_abund_df[[i]]$dist &lt;- names(associations_abund)[i] } associations_abund_df &lt;- do.call(rbind, associations_abund_df) ggplot(associations_abund_df, aes(x=row, y=column)) + facet_wrap(. ~ dist, nrow = 2) + geom_tile(aes(fill = value)) + geom_text(aes(label = round(value, 2))) + scale_fill_gradient2(low = &quot;#00ccff&quot;, mid = &quot;#aad400&quot;, high = &quot;#ff0066&quot;, midpoint = 2) + labs(x=&quot;Site&quot;, y=&quot;Site&quot;) Peu importe le type dâ€™association utilisÃ©e, les heatmaps montrent les mÃªmes tendances. Les assocaitions de dissimilaritÃ© (Bray-Curtis, Kulczynski et Ruzicka) sâ€™Ã©talent de 0 Ã  1, tandis que les distances (Chi-Square, Chord et Hellinger) partent de zÃ©ro, mais nâ€™ont pas de limite supÃ©rieure. On note les plus grandes diffÃ©rences entre les sites 2 et 4, tandis que les sites 2 et 3 sont les plus semblables pour toutes les mesures dâ€™association Ã  lâ€™exception de la dissimilaritÃ© de Kulczynski. 8.2.1.2 Objets: Occurence (prÃ©sence-absence) Des indices dâ€™association diffÃ©rents devraient Ãªtre utilisÃ©s lorsque des donnÃ©es sont compilÃ©es sous forme boolÃ©enne. En gÃ©nÃ©ral, les tableaux de donnÃ©es dâ€™occurence seront compilÃ©s avec des 1 (prÃ©sence) et des 0 (absence). La similaritÃ© de Jaccard entre le site A et le site B est la proportion de double 1 (prÃ©sences de 1 dans A et B) parmi les espÃ¨ces. La dissimilariÃ© est la proportion complÃ©mentaire (comprenant [1, 0], [0, 1] et [0, 0]). La distance de Jaccard est la racine carrÃ©e de la dissimilaritÃ©. associations_occ &lt;- list() associations_occ[[&#39;Jaccard&#39;]] &lt;- vegdist(occurence, method = &quot;jaccard&quot;) Les distances dâ€™Hellinger, de chord et de chi-carrÃ© sont aussi appropriÃ©es pour les calculs de distances sur des tableaux dâ€™occurence. associations_occ[[&#39;Hellinger&#39;]] &lt;- dist(decostand(occurence, method=&quot;hellinger&quot;)) associations_occ[[&#39;Chord&#39;]] &lt;- dist(decostand(occurence, method=&quot;normalize&quot;)) associations_occ[[&#39;ChiSquare&#39;]] &lt;- dist(decostand(occurence, method=&quot;chi.square&quot;)) Graphiquement, associations_occ_df &lt;- list() for (i in 1:length(associations_occ)) { associations_occ_df[[i]] &lt;- data.frame(as.matrix(associations_occ[[i]])) colnames(associations_occ_df[[i]]) &lt;- rownames(associations_occ_df[[i]]) associations_occ_df[[i]]$row &lt;- rownames(associations_occ_df[[i]]) associations_occ_df[[i]] &lt;- associations_occ_df[[i]] %&gt;% gather(key=row) associations_occ_df[[i]]$column = rep(1:4, 4) associations_occ_df[[i]]$dist &lt;- names(associations_occ)[i] } associations_occ_df &lt;- do.call(rbind, associations_occ_df) ggplot(associations_occ_df, aes(x=row, y=column)) + facet_wrap(. ~ dist) + geom_tile(aes(fill = value)) + geom_text(aes(label = round(value, 2))) + scale_fill_gradient2(low = &quot;#00ccff&quot;, mid = &quot;#aad400&quot;, high = &quot;#ff0066&quot;, midpoint = 1) + labs(x=&quot;Site&quot;, y=&quot;Site&quot;) Il est attendu que les matrices dâ€™association sur lâ€™occurence sont semblables Ã  celles sur lâ€™abondance. Dans ce cas-ci, la distance dâ€™Hellinger donne des rÃ©sultats semblables Ã  la dissimilaritÃ© de Jaccard. 8.2.1.3 Objets: DonnÃ©es quantitatives Les donnÃ©es quantitative en Ã©cologie peuvent dÃ©crire lâ€™Ã©tat de lâ€™environnement: le climat, lâ€™hydrologie, lâ€™hydrogÃ©ochimie, la pÃ©dologie, etc. En rÃ¨gle gÃ©nÃ©rale, les coordonnÃ©es des sites ne sot pas des variables environnementales, Ã  que lâ€™on soupÃ§onne la coordonnÃ©e elle-mÃªme dâ€™Ãªtre responsable dâ€™effets sur notre systÃ¨me: mais il sâ€™agira la plupart du temps dâ€™effets confondants (par exemple, on peut mesurer un effet de lattitude sur le rendement des agrumes, mais il sâ€™agira probablement avant tout dâ€™effets dus aux conditions climatiques, qui elles changent en fonction de la lattitude). Dâ€™autre types de donnÃ©es quantitative pouvant Ãªtre apprÃ©hendÃ©es par des distances sont les traits phÃ©nologiques, les ionomes, les gÃ©nomes, etc. La distance euclidienne est la racine carrÃ©e de la somme des carrÃ©s des distances sur tous les axes. Il sâ€™agit dâ€™une application multidimensionnelle du thÃ©orÃ¨me de Pythagore. La distance dâ€™Aitchison, couverte dans le chapitre 6, est une distance euclidienne calculÃ©e sur des donnÃ©es compositionnelles prÃ©alablement transformÃ©es. La distance euclidienne est sensible aux unitÃ©s utilisÃ©s: utiliser des milimÃ¨tres plutÃ´t que des mÃ¨tres enflera la distance euclidienne. Il est recommandÃ© de porter une attention particuliÃ¨re aux unitÃ©s, et de standardiser les donnÃ©es au besoin (par exemple, en centrant la moyenne Ã  zÃ©ro et en fixant lâ€™Ã©cart-type Ã  1). On pourrait, par exemple, mesurer la distance entre des observations des dimensions de diffÃ©rentes espÃ¨ces dâ€™iris. Ce tableau est inclu dans R par dÃ©faut. data(iris) iris %&gt;% sample_n(5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.9 3.2 4.8 1.8 versicolor ## 2 5.8 2.6 4.0 1.2 versicolor ## 3 5.4 3.7 1.5 0.2 setosa ## 4 4.4 3.0 1.3 0.2 setosa ## 5 4.8 3.0 1.4 0.1 setosa Les mesures du tableau sont en centimÃ¨tres. Pour Ã©viter de donner davantage de poids aux longueur des sÃ©pales et en mÃªme temps de nÃ©gliger la largeur des pÃ©tales, nous allons standardiser le tableau. iris_sc &lt;- iris %&gt;% select(-Species) %&gt;% scale(.)%&gt;% as_tibble(.) %&gt;% mutate(Species = iris$Species) iris_sc ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 -0.898 1.02 -1.34 -1.31 setosa ## 2 -1.14 -0.132 -1.34 -1.31 setosa ## 3 -1.38 0.327 -1.39 -1.31 setosa ## 4 -1.50 0.0979 -1.28 -1.31 setosa ## 5 -1.02 1.25 -1.34 -1.31 setosa ## 6 -0.535 1.93 -1.17 -1.05 setosa ## 7 -1.50 0.786 -1.34 -1.18 setosa ## 8 -1.02 0.786 -1.28 -1.31 setosa ## 9 -1.74 -0.361 -1.34 -1.31 setosa ## 10 -1.14 0.0979 -1.28 -1.44 setosa ## # â€¦ with 140 more rows Pour les comparaisons des dimensions, prenons la moyenne des dimensions (mises Ã  lâ€™Ã©chelle) par espÃ¨ce. iris_means &lt;- iris_sc %&gt;% group_by(Species) %&gt;% summarise_all(mean) %&gt;% select(-Species) iris_means ## # A tibble: 3 x 4 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -1.01 0.850 -1.30 -1.25 ## 2 0.112 -0.659 0.284 0.166 ## 3 0.899 -0.191 1.02 1.08 Nous pouvons utiliser la distance euclidienne, commune en gÃ©omÃ©trie, pour comparer les espÃ¨ces. La distance euclidienne est calculÃ©e comme suit. \\[ \\mathcal{E} = \\sqrt{\\Sigma_i \\left( A_i - B_i \\right) ^2 } \\] associations_cont = list() associations_cont[[&#39;Euclidean&#39;]] &lt;- dist(iris_sc %&gt;% select(-Species), method=&quot;euclidean&quot;) La distance de Mahalanobis est semblable Ã  la distance euclidienne, mais qui tient compte de la covariance de la matrice des objets. Cette covariance peut Ãªtre utilisÃ©e pour dÃ©crire la structure dâ€™un nuage de points. La figure suivante montre deux points verts qui se trouvent aux extrÃªmes dâ€™un nuage de point. Ces points ont des distances euclidiennes par rapport au centre diffÃ©rentes: les lignes dâ€™Ã©quidistance euclÃ©dienne sont tracÃ©es en rose. Toutefois, les deux points ont un distance de Mahalanobis Ã©gale Ã  partir du centre. Source: Parent et al. (2012). La diastance de Mahalanobis se calcule comme suit. \\[\\mathcal{M} = \\sqrt{(A - B)^T S^{-1} (A-B)}\\] Notez quâ€™il sâ€™agit dâ€™une gÃ©nÃ©ralisation de la distance euclidienne, qui Ã©quivaut Ã  une distance de Mahalanobis dont la matrice de covariance est une matrice identitÃ©. La distance de Mahalanobis permet de reprÃ©senter des distances dans un espace fortement corrÃ©lÃ©. Elle est courramment utilisÃ©e pour dÃ©tecter les valeurs aberrantes selon des critÃ¨res de distance Ã  partir du centre dâ€™un jeu de donnÃ©es multivariÃ©es. associations_cont[[&#39;Mahalanobis&#39;]] &lt;- vegdist(iris_sc %&gt;% select(-Species), &#39;mahalanobis&#39;) La distance de Manhattan porte aussi le nom de distance de cityblock ou de taxi. Câ€™est la distance que vous devrez parcourir pour vous rendre du point A au point B Ã  Manhattan, câ€™est-Ã -dire selon une sÃ©quence de tronÃ§ons perpendiculaires. \\[ D_{AB} = \\sum _i \\left| A_i - B_i \\right| \\] La distance de Manhattan est appropriÃ©e lorsque les gradients (changements dâ€™un Ã©tat Ã  lâ€™autre ou dâ€™une rÃ©gion Ã  lâ€™autre) ne permettent pas des changements simultanÃ©s. Mieux vaut standardiser les variables pour Ã©viter quâ€™une dimension soit prÃ©pondÃ©rante. associations_cont[[&#39;Manhattan&#39;]] &lt;- vegdist(iris_sc %&gt;% select(-Species), &#39;manhattan&#39;) Graphiquement associations_cont_df &lt;- list() for (i in 1:length(associations_cont)) { associations_cont_df[[i]] &lt;- data.frame(as.matrix(associations_cont[[i]])) colnames(associations_cont_df[[i]]) &lt;- rownames(associations_cont_df[[i]]) associations_cont_df[[i]]$row &lt;- rownames(associations_cont_df[[i]]) associations_cont_df[[i]] &lt;- associations_cont_df[[i]] %&gt;% gather(key=row) associations_cont_df[[i]]$column = rep(1:nrow(iris), nrow(iris)) associations_cont_df[[i]]$dist &lt;- names(associations_cont)[i] } associations_cont_df &lt;- do.call(rbind, associations_cont_df) ggplot(associations_cont_df, aes(x=row, y=column)) + facet_wrap(. ~ dist) + geom_tile(aes(fill = value), colour = NA) + #geom_text(aes(label = round(value, 2))) + scale_fill_gradient2(low = &quot;#00ccff&quot;, mid = &quot;#aad400&quot;, high = &quot;#ff0066&quot;, midpoint = 5) + labs(x=&quot;Site&quot;, y=&quot;Site&quot;) Le tableau iris est ordonnÃ© par espÃ¨ce. Les distances euclidienne et de Manhattan permettent aisÃ©ment de distinguer les espÃ¨ces selon les dimensions des pÃ©tales et des sÃ©pales. Toutefois, lâ€™utilsation de la covariance avec la distance de Mahalanobis crÃ©e des distinction moins tranchÃ©es. 8.2.1.4 Objets: DonnÃ©es mixtes Les donnÃ©es catÃ©gorielles ordinales peuvent Ãªtre transformÃ©es en donnÃ©es continues par gradations linÃ©aires ou quadratiques. Les donnÃ©es catÃ©gorielles nominales, quant Ã  elles, peuvent Ãªtre dummyfiÃ©es en donnÃ©es similaires Ã  des occurences. Attention toutefois: contrairement Ã  la rÃ©gression linÃ©aire qui demande dâ€™exclure une catÃ©gorie, la dummyfication doit inclure toutes les catÃ©gories. Le comportement par dÃ©faut de la fonction pandas.get_dummies est de garder toutes les catÃ©gories. La similaritÃ© de Gower a Ã©tÃ© dÃ©veloppÃ©e pour mesurer des associations entre des objets dont les donnÃ©es sont mixtes: boolÃ©ennes, catÃ©gorielles et continues. La similaritÃ© de Gower est calculÃ©e en additionnant les distances calculÃ©es par colonne, individuellement. Si la colonne est boolÃ©enne, on utilise les distances de Jaccard (qui exclue les double-zÃ©ro) de maniÃ¨re univariÃ©e: une variable Ã  la fois. Pour les variables continues, on utilise la distance de Manhattan divisÃ©e par la plage de valeurs de la variable (pour fin de standardisation). Puisquâ€™elle hÃ©rite de la particularitÃ© de la distance de Manhattan et de la similaritÃ© de Jaccard univariÃ©e, la similaritÃ© de Gower reste une combinaison linÃ©aire de distances univariÃ©es. X &lt;- tibble(ID = 1:8, age = c(21, 21, 19, 30, 21, 21, 19, 30), gender = c(&#39;M&#39;,&#39;M&#39;,&#39;N&#39;,&#39;M&#39;,&#39;F&#39;,&#39;F&#39;,&#39;F&#39;,&#39;F&#39;), civil_status = c(&#39;MARRIED&#39;,&#39;SINGLE&#39;,&#39;SINGLE&#39;,&#39;SINGLE&#39;,&#39;MARRIED&#39;,&#39;SINGLE&#39;,&#39;WIDOW&#39;,&#39;DIVORCED&#39;), salary = c(3000.0,1200.0 ,32000.0,1800.0 ,2900.0 ,1100.0 ,10000.0,1500.0), children = c(TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE), available_credit = c(2200,100,22000,1100,2000,100,6000,2200)) X ## # A tibble: 8 x 7 ## ID age gender civil_status salary children available_credit ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; ## 1 1 21 M MARRIED 3000 TRUE 2200 ## 2 2 21 M SINGLE 1200 FALSE 100 ## 3 3 19 N SINGLE 32000 TRUE 22000 ## 4 4 30 M SINGLE 1800 TRUE 1100 ## 5 5 21 F MARRIED 2900 TRUE 2000 ## 6 6 21 F SINGLE 1100 TRUE 100 ## 7 7 19 F WIDOW 10000 FALSE 6000 ## 8 8 30 F DIVORCED 1500 TRUE 2200 Il faut prÃ©alablement dummifier les variables catÃ©gorielles nominales. X_dum &lt;- model.matrix(~ 0 + ., X[, -1]) X_dum ## age genderF genderM genderN civil_statusMARRIED civil_statusSINGLE ## 1 21 0 1 0 1 0 ## 2 21 0 1 0 0 1 ## 3 19 0 0 1 0 1 ## 4 30 0 1 0 0 1 ## 5 21 1 0 0 1 0 ## 6 21 1 0 0 0 1 ## 7 19 1 0 0 0 0 ## 8 30 1 0 0 0 0 ## civil_statusWIDOW salary childrenTRUE available_credit ## 1 0 3000 1 2200 ## 2 0 1200 0 100 ## 3 0 32000 1 22000 ## 4 0 1800 1 1100 ## 5 0 2900 1 2000 ## 6 0 1100 1 100 ## 7 1 10000 0 6000 ## 8 0 1500 1 2200 ## attr(,&quot;assign&quot;) ## [1] 1 2 2 2 3 3 3 4 5 6 ## attr(,&quot;contrasts&quot;) ## attr(,&quot;contrasts&quot;)$gender ## [1] &quot;contr.treatment&quot; ## ## attr(,&quot;contrasts&quot;)$civil_status ## [1] &quot;contr.treatment&quot; ## ## attr(,&quot;contrasts&quot;)$children ## [1] &quot;contr.treatment&quot; Calculons la dissimilaritÃ© de Gower (cette fois le graphique est fait avec pheatmap). library(&quot;pheatmap&quot;) d_gow &lt;- as.matrix(vegdist(X_dum, &#39;gower&#39;)) colnames(d_gow) &lt;- rownames(d_gow) &lt;- X$ID pheatmap(d_gow) Les dendrogrammes apparaissants sur les axes du graphique sont issus dâ€™un processus de partitionnement basÃ© sur la distance, que nous verrons plus loin dans ce chapiter. Les profils des clients 4 et 7, ainsi que ceux des clients 3 et 7 diffÃ¨rent le plus. Les profils 3 et 4 sont nÃ©anmoins plutÃ´t diffÃ©rents. 8.2.2 Associations entre variables (mode R) Il existe de nombreuses approches pour mesurer les associations entre variables. La plus connue est la corrÃ©lation. Mais les donnÃ©es dâ€™abondance et dâ€™occurence demandent des approches diffÃ©rentes. 8.2.2.1 Variables: Abondance La distance du chi-carrÃ© est suggÃ©rÃ©e par Borcard et al. (2011). abundance_r &lt;- t(abundance) D_chisq_R &lt;- as.matrix(dist(decostand(abundance_r, method=&quot;chi.square&quot;))) pheatmap(D_chisq_R, display_numbers = round(D_chisq_R, 2)) Des coabondances sont notables pour la mÃ©sange Ã  tÃªte noire, le jaseur borÃ©al, la citelle Ã  poitrine rousse et le bruant Ã  gorge blanche (tache bleu au centre). 8.2.2.2 Variables: Occurence La dissimilaritÃ© de Jaccard peut Ãªtre utilisÃ©e. occurence_r &lt;- t(occurence) D_jacc_R &lt;- as.matrix(vegdist(occurence_r, method = &quot;jaccard&quot;)) pheatmap(D_jacc_R, display_numbers = round(D_jacc_R, 2)) Des cooccurences sont notables pour le jaseur borÃ©al, la citelle Ã  poitrine rousse et le bruant Ã  gorge blanche (tache bleu au centre). 8.2.2.3 Variables: QuantitÃ©s La matrice des corrÃ©lations de Pearson peut Ãªtre utilisÃ©e pour les donnÃ©es continues. Quant aux variables ordinales, elles devraient idÃ©alement Ãªtre liÃ©es linÃ©airement ou quadratiquement. Si ce nâ€™est pas le cas, câ€™est-Ã -dire que les catÃ©gories sont ordonnÃ©es par rang seulement, vous pourrez avoir recours aux coefficients de corrÃ©lation de Spearman ou de Kendall. iris_cor &lt;- iris %&gt;% select(-Species) %&gt;% cor(.) pheatmap(iris_cor, cluster_rows = FALSE, cluster_cols = FALSE, display_numbers = round(iris_cor, 2)) 8.2.3 Conclusion sur les associations Il nâ€™existe pas de rÃ¨gle claire pour dÃ©terminer quelle technique dâ€™association utiliser. Cela dÃ©pend en premier lieu de vos donnÃ©es. Vous sÃ©lectionnerez votre mÃ©thode dâ€™association selon le type de donnÃ©es que vous abordez, la question Ã  laquelle vous dÃ©sirez rÃ©pondre ainsi lâ€™expÃ©rience dans la littÃ©rature comme celle de vos collÃ¨gues scientifiques. Sâ€™il nâ€™existe pas de rÃ¨gle clair, câ€™est quâ€™il existe des dizaines de mÃ©thodes diffÃ©rentes, et la plupart dâ€™entre elles vous donneront une perspective juste et valide. Il faut nÃ©anmoins faire attention pour Ã©viter de sÃ©lectionner les mÃ©thodes qui ne sont pas appropriÃ©es. 8.3 Partitionnement Les donnÃ©es suivantes ont Ã©tÃ© gÃ©nÃ©rÃ©es par Leland McInnes (Tutte institute of mathematics, Ottawa). ÃŠtes-vous en mesure dâ€™identifier des groupes? Combien en trouvez-vous? df_mcinnes &lt;- read_csv(&quot;data/clusterable_data.csv&quot;, col_names = c(&quot;x&quot;, &quot;y&quot;), skip = 1) ## Parsed with column specification: ## cols( ## x = col_double(), ## y = col_double() ## ) ggplot(df_mcinnes, aes(x=x, y=y)) + geom_point() + coord_fixed() En 2D, lâ€™oeil humain peut facilement dÃ©tecter les groupes. En 3D, câ€™est toujours possible, mais au-delÃ  de 3D, le partitionnement cognitive devient rapidement maladroite. Les algorithmes sont alors dâ€™une aide prÃ©cieuse. Mais ils transportent en pratique tout un baggage de limitations. Quel est le critÃ¨re dâ€™association entre les groupes? Combien de groupe devrions-nous crÃ©er? Comment distinguer une donnÃ©e trop bruitÃ©e pour Ãªtre classifiÃ©e? Le partitionnement de donnÃ©es (clustering en anglais), et inversement leur regroupement, permet de crÃ©er des ensembles selon des critÃ¨res dâ€™association. On suppose donc que Le partitionnement permet de crÃ©er des groupes selon lâ€™information que lâ€™on fait Ã©merger des donnÃ©es. Il est consÃ©quemment entendu que les donnÃ©es ne sont pas catÃ©gorisÃ©es Ã  priori: il ne sâ€™agit pas de prÃ©dire la catÃ©gorie dâ€™un objet, mais bien de crÃ©er des catÃ©gories Ã  partir des objets par exemple selon leurs dimensions, leurs couleurs, leurs signature chimique, leurs comportements, leurs gÃ¨nes, etc. Plusieurs mÃ©thodes sont aujourdâ€™hui offertes aux analystes pour partitionner leurs donnÃ©es. Dans le cadre de ce manuel, nous couvrirons ici deux grandes tendances dans les algorithmes. MÃ©thodes hiÃ©rarchique et non hiÃ©rarchiques. Dans un partitionnement hiÃ©rarchique, lâ€™ensemble des objets forme un groupe, comprenant des sous-regroupements, des sous-sous-regroupements, etc., dont les objets forment lâ€™ultime partitionnement. On pourra alors identifier comment se dÃ©cline un partitionnement. Ã€ lâ€™inverse, un partitionnement non-hiÃ©rarchique des algorhitmes permettent de crÃ©er les groupes non hiÃ©rarchisÃ©s les plus diffÃ©rents que possible. Membership exclusif ou flou. Certaines techniques attribuent Ã  chaque une classe unique: lâ€™appartenance sera indiquÃ©e par un 1 et la non appartenance par un 0. Dâ€™autres techniques vont attribuer un membership flou oÃ¹ le degrÃ© dâ€™appartenance est une variable continue de 0 Ã  1. Parmi les mÃ©thodes floues, on retrouve les mÃ©thodes probabilistes. 8.3.1 Ã‰valuation dâ€™un partitionnement Le choix dâ€™une technique de partitionnement parmi de nombreuses disponibles, ainsi que le choix des paramÃ¨tres gouvernant chacune dâ€™entre elles, est avant tout basÃ© sur ce que lâ€™on dÃ©sire dÃ©finir comme Ã©tant un groupe, ainsi que la maniÃ¨re dâ€™interprÃ©ter les groupes. En outre, le nombre de groupe Ã  dÃ©partager est toujours une dÃ©cision de lâ€™analyste. NÃ©anmoins, on peut se fier des indicateurs de performance de partitionnement. Parmis ceux-ci, retenons le score silouhette ainsi que lâ€™indice de Calinski-Harabaz. 8.3.1.1 Score silouhette En anglais, le h dans silouhette se trouve aprÃ¨s le l: on parle donc de silhouette coefficient pour dÃ©signer le score de chacun des objets dans le partitionnement. Pour chaque objet, on calcule la distance moyenne qui le sÃ©pare des autres points de son groupe (\\(a\\)) ainsi que la distance moyenne qui le sÃ©pare des points du groupe le plus rapprochÃ©. \\[s = \\frac{b-a}{max \\left(a, b \\right)}\\] Un coefficient de -1 indique le pire classement, tandis quâ€™un coefficient de 1 indique le meilleur classement. La moyenne des coefficients silouhette est le score silouhette. 8.3.1.2 Indice de Calinski-Harabaz Lâ€™indice de Calinski-Harabaz est proportionnel au ratio des dispersions intra-groupe et la moyenne des dispersions inter-groupes. Plus lâ€™indice est Ã©levÃ©, mieux les groupes sont dÃ©finis. La mathÃ©matique est dÃ©crite dans la documentation de scikit-learn, un module dâ€™analyse et autoapprentissage sur Python. Note. Les coefficients silouhette et lâ€™indice de Calinski-Harabaz sont plus appropriÃ©s pour les formes de groupes convexes (cercles, sphÃ¨res, hypersphÃ¨res) que pour les formes irrÃ©guliÃ¨res (notamment celles obtenues par la DBSCAN, discutÃ©e ci-desssous). 8.3.2 Partitionnement non hiÃ©rarchique Il peut arriver que vous nâ€™ayez pas besoin de comprendre la structure dâ€™agglomÃ©ration des objets (ou variables). Plusieurs techniques de partitionnement non hiÃ©rarchique sont disponibles dans le module scikit-learn. On sâ€™intÃ©ressera en particulier Ã  celles-ci. Kmeans. Lâ€™objectif des kmeans est de minimiser la distance euclÃ©dienne entre un nombre prÃ©dÃ©fini de k groupes exclusifs. Lâ€™algorhitme commence par placer une nombre k de centroides au hasard dans lâ€™espace dâ€™un nombre p de variables (vous devez fixer k, et p est le nombre de colonnes de vos donnÃ©es). Ensuite, chaque objet est Ã©tiquettÃ© comme appartenant au groupe du centroid le plus prÃ¨s. La position du centroide est dÃ©placÃ©e Ã  la moyenne de chaque groupe. Recommencer Ã  partir de lâ€™Ã©tape 2 jusquâ€™Ã  ce que lâ€™assignation des objets aux groupes ne change plus. Source: David Sheehan La technique des kmeans suppose que les groupes ont des distributions multinormales - reprÃ©sentÃ©es par des cercles en 2D, des sphÃ¨res en 3D, des hypersphÃ¨res en plus de 3D. Cette limitation est problÃ©matique lorsque les groupes se prÃ©sentent sous des formes irrÃ©guliÃ¨res, comme celles du nuage de points de Leland McInnes, prÃ©sentÃ© plus haut. De plus, la technique classique des kmeans est basÃ©e sur des distances euclidiennes: lâ€™utilisation des kmeans nâ€™est appropriÃ©e pour les donnÃ©es comprenant beaucoup de zÃ©ros, comme les donnÃ©es dâ€™abondance, qui devraient prÃ©alablement Ãªtre transformÃ©es en variables centrÃ©es et rÃ©duites (Legendre et Legendre, 2012). La technique des mixtures gaussiennes (gaussian mixtures) est une gÃ©nÃ©ralisation des kmeans permettant dâ€™intÃ©grer la covariance des groupes. Les groupes ne sont plus des hyper-sphÃ¨res, mais des hyper-ellipsoÃ¯des. DBSCAN. La technique DBSCAN (* Density-Based Spatial Clustering of Applications with Noise) sousentend que les groupes sont composÃ©s de zones oÃ¹ lâ€™on retrouve plus de points (zones denses) sÃ©parÃ©es par des zones de faible densitÃ©. Pour lancer lâ€™algorithme, nous devons spÃ©cifier une mesure dâ€™association critique (distance ou dissimilaritÃ©) d* ainsi quâ€™un nombre de point critique k dans le voisinage de cette distance. Lâ€™algorithme comme Ã©tiqueter chaque point selon lâ€™une de ces catÃ©gories: Noyau: le point a au moins k points dans son voisinage, câ€™est-Ã -dire Ã  une distance infÃ©rieure ou Ã©gale Ã  d. Bordure: le point a moins de k points dans son voisinage, mais lâ€™un de des points voisins est un noyau. Bruit: le cas Ã©chÃ©ant. Ces points sont considÃ©rÃ©s comme des outliers. Les noyaux distancÃ©s de d ou moins sont connectÃ©s entre eux en englobant les bordures. Le nombre de groupes est prescrit par lâ€™algorithme DBSCAN, qui permet du coup de dÃ©tecter des donnÃ©es trop bruitÃ©es pour Ãªtre classÃ©es. Damiani et al. (2014) a dÃ©veloppÃ© une approche utilisant la technique DBSCAN pour partitionner des zones dâ€™escale pour les flux de populations migratoires. 8.3.2.1 Application Nous pouvons utilisÃ© la fonction kmeans de R. Toutefois, puisque lâ€™on dÃ©sire ici effectuer des tests de partitionnement pour plusieurs nombres de groupes, nous utiliserons cascadeKM, du module vegan. Notez que de nombreux paramÃ¨tres par dÃ©faut sont utilisÃ©s dans les exÃ©cutions ci-dessous. Ces notes de cours ne forment pas un travail de recherche scientifique. Lors de travaux de recherche, lâ€™utilsation dâ€™un argument ou dâ€™un autre dans une fonction doit Ãªtre justifiÃ©: quâ€™un paramÃ¨tre soit utilisÃ© par dÃ©faut dans une fonction nâ€™est a priori pas une justification convainquante. Pour les kmeans, on doit fixer le nombre de groupes. Le graphique des donnÃ©es de Leland McInnes montrent 6 groupes. Toutefois, il est rare que lâ€™on puisse visualiser des dÃ©marquations aussi tranchÃ©es que celles de lâ€™exemple, qui plus est dans des cas oÃ¹ lâ€™on doit traiter de plus de deux dimensions. Je vais donc lancer le partitionnement en boucle pour plusieurs nombres de groupes, de 3 Ã  10 et pour chaque groupe, Ã©valuer le score silouhette et de Calinski-Habaraz. Jâ€™utilise un argument random_state pour mâ€™assurer que les groupes seront les mÃªmes Ã  chaque fois que la cellule sera lancÃ©e. library(&quot;vegan&quot;) mcinnes_kmeans &lt;- cascadeKM(df_mcinnes, inf.gr = 3, sup.gr = 10, criterion = &quot;calinski&quot;) str(mcinnes_kmeans) ## List of 4 ## $ partition: int [1:2309, 1:8] 2 2 2 2 2 2 2 2 2 2 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:2309] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. ..$ : chr [1:8] &quot;3 groups&quot; &quot;4 groups&quot; &quot;5 groups&quot; &quot;6 groups&quot; ... ## $ results : num [1:2, 1:8] 85.1 2164.5 61.4 2294.6 51.4 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:2] &quot;SSE&quot; &quot;calinski&quot; ## .. ..$ : chr [1:8] &quot;3 groups&quot; &quot;4 groups&quot; &quot;5 groups&quot; &quot;6 groups&quot; ... ## $ criterion: chr &quot;calinski&quot; ## $ size : int [1:10, 1:8] 505 1243 561 NA NA NA NA NA NA NA ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:10] &quot;Group 1&quot; &quot;Group 2&quot; &quot;Group 3&quot; &quot;Group 4&quot; ... ## .. ..$ : chr [1:8] &quot;3 groups&quot; &quot;4 groups&quot; &quot;5 groups&quot; &quot;6 groups&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;cascadeKM&quot; Lâ€™objet mcinnes_kmeans, de type cascadeKM, peut Ãªtre visualisÃ© directement avec la fonction plot. plot(mcinnes_kmeans) On obtient un maximum de Calinski Ã  4 groupes, qui correspons Ã  la deuxiÃ¨me simulation effectuÃ©e de 3 Ã  10. Examinons les scoers silouhette (module: cluster). library(&quot;cluster&quot;) asw &lt;- c() for (i in 1:ncol(mcinnes_kmeans$partition)) { mcinnes_kmeans_silhouette &lt;- silhouette(mcinnes_kmeans$partition[, i], dist = vegdist(df_mcinnes, method = &quot;euclidean&quot;)) asw[i] &lt;- summary(mcinnes_kmeans_silhouette)$avg.width } plot(3:10, asw, type = &#39;b&#39;) Le score silouhette maximum est Ã  3 groupes. La forme des groupes nâ€™Ã©tant pas convexe, il fallait sâ€™attendre Ã  ce que indicateurs maximaux pour les deux indicateurs soient diffÃ©rents. Câ€™est dâ€™ailleurs souvent le cas. Cet exemple supporte que le choix du nombre de groupe Ã  dÃ©partager repose sur lâ€™analyste, non pas uniquement sur les indicateurs de performance. Choisissons 6 groupes, puisque que câ€™est visuellement ce que lâ€™on devrait chercher pour ce cas dâ€™Ã©tude. kmeans_group &lt;- mcinnes_kmeans$partition[, 4] mcinnes_kmeans$partition %&gt;% head(3) ## 3 groups 4 groups 5 groups 6 groups 7 groups 8 groups 9 groups 10 groups ## 1 2 3 2 5 6 7 5 3 ## 2 2 3 3 3 6 6 5 3 ## 3 2 4 2 5 2 7 9 1 df_mcinnes %&gt;% mutate(kmeans_group = kmeans_group) %&gt;% # ajouter une colonne de regoupement ggplot(aes(x=x, y=y)) + geom_point(aes(colour = factor(kmeans_group))) + coord_fixed() Lâ€™algorithme kmeans est loin dâ€™Ãªtre statisfaisant. Cela est attendu, puisque les kmeans recherchent des distribution gaussiennes sur des groupes vraisemblablement non-gaussiens. Nous pouvons crÃ©er un graphique silouhette pour nos 6 groupes. Notez quâ€™Ã  cause dâ€™un bogue, il nâ€™est pas possible de prÃ©senter les donnÃ©es clairement lorsquâ€™elles sont nombreuses. sil &lt;- silhouette(mcinnes_kmeans$partition[, 6], dist = vegdist(df_mcinnes[, ], method = &quot;euclidean&quot;)) sil &lt;- sortSilhouette(sil) plot(sil, col = &#39;black&#39;) La technique DBSCAN nâ€™est pas basÃ©e sur le nombre de groupe, mais sur la densitÃ© des points. Lâ€™argument x ne constitue pas les donnÃ©es, mais une matrice dâ€™association. Lâ€™argument minPts spÃ©cifie le nombre minimal de points qui lâ€™on doit retrouver Ã  une distance critique d* pour la formation des *noyaux et la propagation des groupes, spÃ©cifiÃ©e dans lâ€™argument eps. La distance d peut Ãªtre estimÃ©e en prenant une fraction de la moyenne, mais on aura volontiers recours Ã  sont bon jugement. library(&quot;dbscan&quot;) mcinnes_dbscan &lt;- dbscan(x = vegdist(df_mcinnes[, ], method = &quot;euclidean&quot;), eps = 0.03, minPts = 10) dbscan_group &lt;- mcinnes_dbscan$cluster unique(dbscan_group) ## [1] 1 0 2 6 3 4 5 Les paramÃ¨tres spÃ©cifiÃ©s donnent 5 groupes (1, 2, ..., 5) et des points trop bruitÃ©s pour Ãªtre classifiÃ©s (Ã©tiquetÃ©s 0). Voyons comment les groupes ont Ã©tÃ© formÃ©s. df_mcinnes %&gt;% mutate(dbscan_group = dbscan_group) %&gt;% # ajouter une colonne de regoupement ggplot(aes(x=x, y=y)) + geom_point(aes(colour = factor(dbscan_group))) + coord_fixed() Le partitionnement semble plus conforme Ã  ce que lâ€™on recherche. NÃ©anmoins, DBSCAN crÃ© quelques petits groupes indÃ©sirables (groupe 6, en rose) ainsi quâ€™un grand groupe (violet) qui auraient lieu dâ€™Ãªtre partitionnÃ©. Ces dÃ©faut pourraient Ãªtre rÃ©glÃ©s en jouant sur les paramÃ¨tres eps et minPts. 8.3.3 Partitionnement hiÃ©rarchique Les techniques de partitionnement hiÃ©rarchique sont basÃ©es sur les matrices dâ€™association. La technique pour mesurer lâ€™association (entre objets ou variables) dÃ©terminera en grande partie le paritionnement des donnÃ©es. Les partitionnements hiÃ©rarchiques ont lâ€™avantage de pouvoir Ãªtre reprÃ©sentÃ©s sous forme de dendrogramme (ou arbre) de partition. Un tel dendrogramme prÃ©sente des sous-groupes qui se joignent en groupes jusquâ€™Ã  former un seul ensemble. Le partitionnement hiÃ©rarchique est abondamment utilisÃ© en phylogÃ©nie, pour Ã©tudier les relations de parentÃ© entre organismes vivants, populations dâ€™organismes et espÃ¨ces. La phÃ©nÃ©tique, branche empirique de la phylogÃ©nÃ¨se interspÃ©cifique, fait usage du partitionnement hiÃ©rarchique Ã  partir dâ€™associations gÃ©nÃ©tiques entre unitÃ©s taxonomiques. On retrouve de nombreuses ressources acadÃ©miques en phylogÃ©nÃ©tique ainsi que des outils pour R et Python. Toutefois, la phylogÃ©nÃ©tique en particulier ne fait pas partie de la prÃ©sente ittÃ©ration de ce manuel. 8.3.3.1 Techniques de partitionnement hiÃ©rarchique Le partitionnement hiÃ©rarchique est typiquement effectuÃ© avec une des quatres mÃ©thodes suivantes, dont chacune possÃ¨de ses particularitÃ©s, mais sont toutes agglomÃ©ratives: Ã  chaque Ã©tape dâ€™agglomÃ©ration, on fusionne les deux groupes ayant le plus dâ€™affinitÃ© sur la base des deux sous-groupes les plus rapprochÃ©s. Single link (single). Les groupes sont agglomÃ©rÃ©s sur la base des deux points parmi les groupes, qui sont les plus proches. Complete link (complete). Ã€ la diffÃ©rence de la mÃ©thode single, on considÃ¨re comme critÃ¨re dâ€™agglomÃ©ration les Ã©lÃ©ments les plus Ã©loignÃ©s de chaque groupe. AgglomÃ©ration centrale. Il sâ€™agit dâ€™une fammille de mÃ©thode basÃ©es sur les diffÃ©rences entre les tendances centrales des objets ou des groupes. Average (average). AppelÃ©e UPGMA (Unweighted Pair-Group Method unsing Average), les groupes sont agglomÃ©rÃ©s selon un centre calculÃ©s par la moyenne et le nombre dâ€™objet pondÃ¨re lâ€™agglomÃ©ration (le poids des groupes est retirÃ©). Cette technique est historiquement utilisÃ©e en bioinformatique pour partitionner des groupes phylogÃ©nÃ©tiques (Sneath et Sokal, 1973). Weighted (weighted). La version de average, mais non pondÃ©rÃ©e (WPGMA). Centroid (centroid). Tout comme average, mais le centroÃ¯de (centre gÃ©omÃ©trique) est utilisÃ© au lieu de la moyenne. Accronyme: UPGMC. Median (median). AppelÃ©e WPGMC. Devinez! ;) Ward (ward). Lâ€™optimisation vise Ã  minimiser les sommes des carrÃ©s par regroupement. 8.3.3.2 Quel outil de partitionnement hiÃ©rarchique utiliser? Alors que le choix de la matrice dâ€™association dÃ©pend des donnÃ©es et de leur contexte, la technique de partitionnement hiÃ©rarchique peut, quant Ã  elle, Ãªtre basÃ©e sur un critÃ¨re numÃ©rique. Il en existe plusieurs, mais le critÃ¨re recommandÃ© pour le choix dâ€™une technique de partitionnement hiÃ©rarchique est la corrÃ©lation cophÃ©nÃ©tique. La distance cophÃ©nÃ©tique est la distance Ã  laquelle deux objets ou deux sous-groupes deviennent membres dâ€™un mÃªme groupe. La corrÃ©lation cophÃ©nÃ©tique est la corrÃ©lation de Pearson entre le vecteur dâ€™association des objets et le vecteur de distances cophÃ©nÃ©tiques. 8.3.3.3 Application Les techniques de partitionnement hiÃ©rarchique prÃ©sentÃ©es ci-dessus sont disponibles dans le module stats de R, qui est chargÃ© automatiquement lors de lâ€™ouversture de R. Nous allons classifier les dimensions des iris grÃ¢ce Ã  la distance de Manhattan. mcinnes_hclust_distmat &lt;- vegdist(df_mcinnes, method = &quot;manhattan&quot;) clustering_methods &lt;- c(&#39;single&#39;, &#39;complete&#39;, &#39;average&#39;, &#39;centroid&#39;, &#39;ward&#39;) clust_l &lt;- list() coph_corr_l &lt;- c() for (i in seq_along(clustering_methods)) { clust_l[[i]] &lt;- hclust(mcinnes_hclust_distmat, method = clustering_methods[i]) coph_corr_l[i] &lt;- cor(mcinnes_hclust_distmat, cophenetic(clust_l[[i]])) } ## The &quot;ward&quot; method has been renamed to &quot;ward.D&quot;; note new &quot;ward.D2&quot; tibble(clustering_methods, coph_corr = coph_corr_l) %&gt;% ggplot(aes(x = clustering_methods, y = coph_corr)) + geom_col() La mÃ©thode average retourne la corrÃ©lation la plus Ã©levÃ©e. Pour plus de flexibilitÃ©, enchÃ¢ssons le nom de la mÃ©thode dans une variable. Ainsi, en chageant le nom de cette variable, le reste du code sera consÃ©quent. names(clust_l) &lt;- clustering_methods best_method &lt;- &quot;average&quot; Le partitionnement hiÃ©rarchique peut Ãªtre visualisÃ© par un dendrogramme. plot(clust_l[[best_method]]) 8.3.3.4 Combien de groupes utiliser? La longueur des lignes verticales est la distance sÃ©parant les groupes enfants. Bien que la sÃ©lection du nombre de groupe soit avant tout basÃ©e sur les besoins du problÃ¨me, nous pouvons nous appuyer sur certains outils. La hauteur totale peut servir de critÃ¨re pour dÃ©finir un nombre de groupes adÃ©quat. On pourra sÃ©lectionner le nombre de groupe oÃ¹ la hauteur se stabilise en fonction du nombre de groupe. On pourra aussi utiliser le graphique silhouette, comprenant une collection de largeurs de silouhette, reprÃ©sentant le degrÃ© dâ€™appartenance Ã  son groupe. La fonction sklearn.metrics.silhouette_score, du module scikit-learn, sâ€™en occupe. asw &lt;- c() num_groups &lt;- 3:10 for(i in seq_along(num_groups)) { sil &lt;- silhouette(cutree(clust_l[[best_method]], k = num_groups[i]), mcinnes_hclust_distmat) asw[i] &lt;- summary(sil)$avg.width } plot(num_groups, asw, type = &quot;b&quot;) Le nombre optimal de groupes serait de 5. Coupons le dendrorgamme Ã  la hauteur correspondant Ã  5 groupes avec la fonction cutree. k_opt &lt;- num_groups[which.max(asw)] hclust_group &lt;- cutree(clust_l[[best_method]], k = k_opt) plot(clust_l[[best_method]]) rect.hclust(clust_l[[best_method]], k = k_opt) La classification hiÃ©rarchique, uniquement basÃ©e sur la distance, peut Ãªtre inappropriÃ©e pour dÃ©finir des formes complexes. df_mcinnes %&gt;% mutate(hclust_group = hclust_group) %&gt;% # ajouter une colonne de regoupement ggplot(aes(x=x, y=y)) + geom_point(aes(colour = factor(hclust_group))) + coord_fixed() 8.3.4 Partitionnement hiÃ©rarchique basÃ©e sur la densitÃ© des points La tecchinque HDBSCAN, dont lâ€™algorithme est relativement rÃ©cent (Campello et al., 2013), permet une partitionnement hiÃ©rarchique sur le mÃªme principe des zones de densitÃ© de la technique DBSCAN. Le HDBSCAN a Ã©tÃ© utilisÃ©e pour partitionner les lieux dâ€™escale dâ€™oiseaux migrateurs en Chine (Xu et al., 2013). Avec DBSCAN, un rayon est fixÃ© dans une mÃ©trique appropriÃ©e. Pour chaque point, on compte le nombre de point voisins, câ€™est Ã  dire le nombre de point se situant Ã  une distance (ou une dissimilaritÃ©) Ã©gale ou infÃ©rieure au rayon fixÃ©. Avec HDBSCAN, on spÃ©cifie le nombre de points devant Ãªtre recouverts et on calcule le rayon nÃ©cessaire pour les recouvrir. Ainsi, chaque point est associÃ© Ã  un rayon critique que lâ€™on nommera \\(d_{noyau}\\). La mÃ©trique initiale est ensuite altÃ©rÃ©e: on remplace les associations entre deux objets A et B par la valeur maximale entre cette association, le rayon critique de A et le rayon critique de B. Cette nouvelle distance est appelÃ©e la distance dâ€™atteinte mutuelle: elle accentue les distances pour les points se trouvant dans des zones peu denses. On applique par la suite un algorithme semblable Ã  la partition hiÃ©rarchique single link: En sâ€™Ã©largissant, les rayons se superposent, chaque superposition de rayon forment graduellement des groupes qui sâ€™agglomÃ¨rent ainsi de maniÃ¨re hiÃ©rarchique. Au lieu dâ€™effectuer une tranche Ã  une hauteur donnÃ©e dans un dendrogramme de partitionnement, la technique HDBSCAN se base sur un dendrogramme condensÃ© qui discarte les sous-groupes comprenant moins de n objets (\\(n_{gr min}\\)). Dans nouveau dendrogramme, on recherche des groupes qui occupent bien lâ€™espace dâ€™analyse. Pour ce faitre, on utilise lâ€™inverse de la distance pour crÃ©er un indicateur de persistance (semblable Ã  la similaritÃ©), \\(\\lambda\\). Pour chaque groupe hiÃ©rarchique dans le dendrogramme condensÃ©, on peut calculer la persistance oÃ¹ le groupe prend naissance. De plus, pour chaque objet dâ€™un groupe, on peut aussi calculer une distance Ã  laquelle il quitte le groupe. La stabilitÃ© dâ€™un groupe est la domme des diffÃ©rences de persistance entre la persistance Ã  la naissance et les persistances des objets. On descend dans le dendrogramme. Si la somme des stabilitÃ© des groupes enfants est plus grande que la stabilitÃ© du groupe parent, on accepte la division. Sinon, le parent forme le groupe. La documentation du module hdbscan pour Python offre une description intuitive et plus exhaustive des principes et algorithme de HDBSCAN. 8.3.4.1 ParamÃ¨tres Outre la mÃ©trique dâ€™association dont nous avons discutÃ©, HDBSCAN demande dâ€™Ãªtre nourri avec quelques paramÃ¨tres importants. En particulier, le nombre minimum dâ€™objets par groupe, \\(n_{gr min}\\) dÃ©pend de la quantitÃ© de donnÃ©es que vous avez Ã  votre disposition, ainsi que de la quantitÃ© dâ€™objets que vous jugez suffisante pour crÃ©er des groupes. Nous utiliserons lâ€™implÃ©mentation de HDBSCAN du module dbscan. Si vous dÃ©sirez davantage dâ€™options, vous prÃ©fÃ©rerez probablement lâ€™implÃ©mentation du module largeVis. mcinnes_hdbscan &lt;- hdbscan(x = vegdist(df_mcinnes, method = &quot;euclidean&quot;), minPts = 20, gen_hdbscan_tree = TRUE, gen_simplified_tree = FALSE) hdbscan_group &lt;- mcinnes_hdbscan$cluster unique(hdbscan_group) ## [1] 6 0 4 3 5 1 2 Nous avons 6 groupes, numÃ©rotÃ©s de 1 Ã  6, ainsi que des Ã©tiquettes identifiant des objets dÃ©signÃ©s comme Ã©tant du bruit de fond, numÃ©rotÃ© 0. Le dendrogramme non condensÃ© peu Ãªtre produit. plot(mcinnes_hdbscan$hdbscan_tree) Difficile dâ€™y voir clair avec autant dâ€™objets. Lâ€™objet mcinnes_hdbscan a un nombre minimum dâ€™objets par groupe de 20. Ce qui permet de prÃ©senter le dendrogramme de maniÃ¨re condensÃ©e. plot(mcinnes_hdbscan) Enfin, un aperÃ§u des stratÃ©gies de partitionnement utilisÃ©s jusquâ€™ici. clustering_group &lt;- df_mcinnes %&gt;% mutate(kmeans_group, hclust_group, dbscan_group, hdbscan_group) %&gt;% gather(-x, -y, key = &quot;method&quot;, value = &quot;cluster&quot;) ## Warning: attributes are not identical across measure variables; ## they will be dropped clustering_group$cluster &lt;- factor(clustering_group$cluster) clustering_group %&gt;% ggplot(aes(x = x, y = y)) + geom_point(aes(colour = cluster)) + facet_wrap(~method, ncol = 2) + coord_equal() + theme_bw() Clairement, le partitionnement avec HDBSCAN donne les meilleurs rÃ©sultats. 8.3.5 Conclusion sur le partitionnement Au chapitre 4, nous avons vu avec le jeu de donnÃ©es â€œdatasaurusâ€ que la visualisation peut permettre de dÃ©tecter des structures en segmentant les donnÃ©es selon des groupes. Or, si les donnÃ©es nâ€™Ã©taient pas Ã©tiquetÃ©es, leur structure serait indÃ©tectable avec les algorithmes disponibles actuellement. Le partitionnement permet dâ€™explorer des donnÃ©es, de dÃ©tecter des tendances et de dÃ©gager des groupes permettant la prise de dÃ©cision. Plusieurs techniques de partitionnement ont Ã©tÃ© prÃ©sentÃ©es. Le choix de la technique sera dÃ©terminante sur la maniÃ¨re dont les groupes seront partitionnÃ©s. La dÃ©finition dâ€™un groupe variant dâ€™un cas Ã  lâ€™autre, il nâ€™existe pas de rÃ¨gle pour prescrire une mÃ©thode ou une autre. La partitionnement hiÃ©rarchique a lâ€™avantage de permetre de visualiser comment les groupes sâ€™agglomÃ¨rent. Parmi les mÃ©thodes de partitionnement hiÃ©rarchique disponibles, les mÃ©thodes basÃ©es sur la densitÃ© permettent une grande flexibilitÃ©, ainsi quâ€™une dÃ©tection dâ€™observations ne faisant partie dâ€™aucun goupe. 8.4 Ordination En Ã©cologie, biologie, agronommie comme en foresterie, la plupart des tableaux de donnÃ©es comprennent de nombreuses variables: pH, nutriments, climat, espÃ¨ces ou cultivars, etc. Lâ€™ordination vise Ã  mettre de lâ€™ordre dans des donnÃ©es dont le nombre Ã©levÃ© de variables peut amener Ã  des difficultÃ©s dâ€™apprÃ©ciation et dâ€™interprÃ©taion (Legendre et Legendre, 2012). Plus prÃ©cisÃ©ment, le terme ordination est utilisÃ© en Ã©cologie pour dÃ©signer les techniques de rÃ©duction dâ€™axe. Lâ€™analyse en composante principale est probablement la plus connue de ces techniques. Mais de nombreuses techniques dâ€™ordination ont Ã©tÃ© dÃ©veloppÃ©es au cours des derniÃ¨res annÃ©es, chacune ayant ses domaines dâ€™application. Les techniques de rÃ©duction dâ€™axe permettent de dÃ©gager lâ€™information la plus importante en projetant une synthÃ¨se des relations entre les observations et entre les variables. Les techniques ne supposant aucune structure a priori sont dites non-contraignantes: elles ne comprennent pas de tests statistiques. Ã€ lâ€™inverse, les ordinations contraignantes lient des variables descriptives avec une ou plusieurs variables prÃ©dictives. La rÃ©fÃ©rence en la matiÃ¨re est indiscutablement (Legendre et Legendre, 2012). Cette section en couvrira quelques unes et vous guidera vers la technique la plus appropriÃ©e pour vos donnÃ©es. 8.4.1 Ordination non contraignante Cette section couvrira lâ€™analyse en composantes principales (ACP), lâ€™analyse de correspondance (AC), lâ€™analyse factorielle (AF) ainsi que lâ€™analyse en coordonnÃ©es principales (ACoP). MÃ©thode Distance prÃ©servÃ©e Variables Analyse en composantes principales (ACP) Distance euclidienne DonnÃ©es quantitatives, relations linÃ©aires (attention aux double-zÃ©ros) Analyse de correspondance (AC) Distance de \\(\\chi^2\\) DonnÃ©es non-nÃ©gatives, dimentionnellement homogÃ¨nes ou binaires, abondance ou occurence Positionnement multidimensionnel (PoMd) Toute mesure de dissimilaritÃ© DonnÃ©es quantitatives, qualitatives nominales/ordinales ou mixtes Source: AdaptÃ© de (Legendre et Legendre, 2012, chapitre 9) 8.4.1.1 Analyse en composantes principales Lâ€™objectif dâ€™une ACP est de reprÃ©senter les donnÃ©es dans un nombre rÃ©duit de dimensions reprÃ©sentant le plus possible la variation dâ€™un tableau de donnÃ©es: elle permet de projetter les donnÃ©es dans un espace oÃ¹ les variables sont combinÃ©es en axes orthogonaux dont le premier axe capte le maximum de variance. Lâ€™ACP peut par exemple Ãªtre utilisÃ©e pour analyser des corrÃ©lations entre variables ou dÃ©gager lâ€™information la plus pertinente dâ€™un tableau de donnÃ©es mÃ©tÃ©o ou de signal en un nombre plus retreint de variables. Lâ€™ACP effectue est une rotation des axes Ã  partir du centre (moyenne) du nuage de points effectuÃ©e de maniÃ¨re Ã  ce que le premier axe dÃ©finisse la direction oÃ¹ lâ€™on retrouve la variance maximale. Ce premier axe est une combinaison linÃ©aire des variables et forme la premiÃ¨re composante principale. Une fois cet axe dÃ©finit, on trouve de deuxiÃ¨me axe, orthogonal au premier, oÃ¹ lâ€™on retouve la variance maximale - cet axe forme la deuxiÃ¨me composante principale, et ainsi de suite jusquâ€™Ã  ce que le nombre dâ€™axe corresponde au nombre de variables. Les projections des observations sur ces axes principaux sont appelÃ©s les scores. Les projections des variables sur les axes principaux sont les vecteurs propres (eigenvectors, ou loadings). La variance des composantes principales diminue de la premiÃ¨re Ã  la derniÃ¨re, et peut Ãªtre calculÃ©e comme une proportion de la variance totale: câ€™est le pourcentage dâ€™inertie. Par convention, on utilise les valeurs propres (eigenvalues) pour mesurer lâ€™importance des axes. Si la premiÃ¨re composante principale a une inertie de 50% et la deuxiÃ¨me a une intertie de 30%, la reprÃ©sentation en 2D des projection reprÃ©sentera 80% de la variance du nuage de points. Lâ€™hÃ©tÃ©rogÃ©nÃ©itÃ© des Ã©chelles de mesure peut avoir une grande importance sur les rÃ©sultats dâ€™une ACP (les donnÃ©es doivent Ãªtre dimensionnellement homogÃ¨nes). En effet, la hauteur dâ€™un ceriser aura une variance plus grande que le diamÃ¨tre dâ€™une cerise exprimÃ© dans les mÃªmes unitÃ©s, et cette derniÃ¨re aura plus de variance que la teneur en cuivre dâ€™une feuille. Il est consÃ©quemment avisÃ© de mettre les donnÃ©es Ã  lâ€™Ã©chelle en centrant la moyenne Ã  zÃ©ro et lâ€™Ã©cart-type Ã  1 avant de procÃ©der Ã  une ACP. Lâ€™ACP a Ã©tÃ© conÃ§ue pour projetter en un nombre moindre de dimensions des observations dont les distributions sont multinormales. Bien que lâ€™ACP soit une technique robuste, il est prÃ©fÃ©rable de transformer prÃ©alablement les variables dont la distribution est particuliÃ¨rement asymÃ©triques (Legendre et Legendre, 2012, p.Â 450). Le cas Ã©chÃ©ant, les valeurs extrÃªmes pourraient faire dÃ©vier les vecteurs propres et biaiser lâ€™analyse. En particulier, les donnÃ©es ACP menÃ©es sur des donnÃ©es compositionnelles sont rÃ©putÃ©es pour gÃ©nÃ©rer des analyses biaisÃ©es (Pawlowsky-Glahn and Egozcue, 2006). Le test de Mardia (Korkmaz, 2014) peut Ãªtre utilisÃ© pour tester la multinormalitÃ©. Une distribution multinormale devrait gÃ©nÃ©rer des scores en forme dâ€™hypersphÃ¨re (en forme de cercle sur un biplot: voir plus loin). 8.4.1.1.1 Vecteurs propres et valeurs propres Une matrice carrÃ©e (comme une matrice de covariance \\(\\Sigma\\)) multipliÃ©e par un vecteur propre \\(e\\) est Ã©gale aux valeurs propres \\(\\lambda\\) multipliÃ©es par les vecteurs propres \\(e\\). \\[ \\Sigma e = \\lambda e \\] De maniÃ¨re intuitive, les vecteurs propres indiquent lâ€™orientation de la covariance, et les valeurs propres indique la longueur associÃ©e Ã  cette direction. Lâ€™ACP est basÃ©e sur le calcul des vecteurs propres et des valeurs propres de la matrice de covariance des variables. Pour dâ€™abord obtenir les valeurs propres \\(\\lambda\\), il faut rÃ©soudre lâ€™Ã©quation \\[ det(cov(X) - \\lambda I) = 0 \\], oÃ¹ \\(det\\) est lâ€™opÃ©ration permettant de calculer le dÃ©terminant, \\(cov\\) est lâ€™opÃ©ration pour calculer la covariance, \\(X\\) est la matrice de donnÃ©es, \\(\\lambda\\) sont les valeurs propres et \\(I\\) est une matrice dâ€™identitÃ©. Pour \\(p\\) variables dans votre tableau \\(X\\), vous obtiendrex \\(p\\) valeurs propres. Ensuite, on trouve les vecteurs propres en rÃ©solvant lâ€™Ã©quation $ e = e $. Bien quâ€™il soit possible dâ€™effectuer cette opÃ©ration Ã  la main pour des cas trÃ¨s simples, vous aurez avantage Ã  utiliser un langage de programmation. Chargeons les donnÃ©es dâ€™iris, puis isolons seulement les deux dimensions des sÃ©pales lâ€™espÃ¨ce setosa. data(&quot;iris&quot;) setosa_sepal &lt;- iris %&gt;% filter(Species == &quot;setosa&quot;) %&gt;% select(starts_with(&quot;Sepal&quot;)) setosa_sepal ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 ## 7 4.6 3.4 ## 8 5.0 3.4 ## 9 4.4 2.9 ## 10 4.9 3.1 ## 11 5.4 3.7 ## 12 4.8 3.4 ## 13 4.8 3.0 ## 14 4.3 3.0 ## 15 5.8 4.0 ## 16 5.7 4.4 ## 17 5.4 3.9 ## 18 5.1 3.5 ## 19 5.7 3.8 ## 20 5.1 3.8 ## 21 5.4 3.4 ## 22 5.1 3.7 ## 23 4.6 3.6 ## 24 5.1 3.3 ## 25 4.8 3.4 ## 26 5.0 3.0 ## 27 5.0 3.4 ## 28 5.2 3.5 ## 29 5.2 3.4 ## 30 4.7 3.2 ## 31 4.8 3.1 ## 32 5.4 3.4 ## 33 5.2 4.1 ## 34 5.5 4.2 ## 35 4.9 3.1 ## 36 5.0 3.2 ## 37 5.5 3.5 ## 38 4.9 3.6 ## 39 4.4 3.0 ## 40 5.1 3.4 ## 41 5.0 3.5 ## 42 4.5 2.3 ## 43 4.4 3.2 ## 44 5.0 3.5 ## 45 5.1 3.8 ## 46 4.8 3.0 ## 47 5.1 3.8 ## 48 4.6 3.2 ## 49 5.3 3.7 ## 50 5.0 3.3 library(&quot;MVN&quot;) ## sROC 0.1-2 loaded setosa_sepal_mvn &lt;- mvn(setosa_sepal, mvnTest = &quot;mardia&quot;) setosa_sepal_mvn$multivariateNormality ## Test Statistic p value Result ## 1 Mardia Skewness 0.759503524380438 0.943793240544741 YES ## 2 Mardia Kurtosis 0.0934600553610254 0.925538081956867 YES ## 3 MVN &lt;NA&gt; &lt;NA&gt; YES Pour considÃ©rer la distribution comme multinormale, la p-value de la distortion (Mardia Skewness) et la statistique de Kurtosis (Mardia Kurtosis) doit Ãªtre Ã©gale ou plus Ã©levÃ©e que 0.05 (Kormaz, 2019, fiche dâ€™aide de la fonction mvn de R). Câ€™est bien le cas pour les donnÃ©es du tableau setosa_sepal. Retirons de la matrice de covariance les valeurs et vecteurs propres avec la fonction eigen. setosa_eigen &lt;- eigen(cov(setosa_sepal)) setosa_eigenval &lt;- setosa_eigen$values setosa_eigenvec &lt;- setosa_eigen$vectors Le premier vecteur propre correspond Ã  la premiÃ¨re colonne, et le second Ã  la deuxiÃ¨me. Les coordonnÃ©es x et y sont les premiÃ¨res et deuxiÃ¨mes lignes. Les vecteurs propres ont une longueur unitaire (norme de 1). Ils peuvent Ãªtre mis Ã  lâ€™Ã©chelles Ã  la racine carrÃ©e des valeurs propres. setosa_eigenvec_sc &lt;- setosa_eigenvec %*% diag(sqrt(setosa_eigen$values)) Pour effectuer une translation des vecteurs propres au centre du nuage de point, nous avons besoin du centroÃ¯de. centroid &lt;- setosa_sepal %&gt;% apply(., 2, mean) plot(setosa_sepal, asp = 1) # vecteurs propres brutes lines(x=c(centroid[1], centroid[1] + setosa_eigenvec[1, 1]), y=c(centroid[2], centroid[2] + setosa_eigenvec[2, 1]), col = &quot;green&quot;, lwd = 3) # vecteur propre 1 lines(x=c(centroid[1], centroid[1] + setosa_eigenvec[1, 2]), y=c(centroid[2], centroid[2] + setosa_eigenvec[2, 2]), col = &quot;green&quot;, lwd = 3) # vecteur propre 1 # vecteurs propres Ã  l&#39;Ã©chelle lines(x=c(centroid[1], centroid[1] + setosa_eigenvec_sc[1, 1]), y=c(centroid[2], centroid[2] + setosa_eigenvec_sc[2, 1]), col = &quot;red&quot;, lwd = 4) # vecteur propre 1 lines(x=c(centroid[1], centroid[1] + setosa_eigenvec_sc[1, 2]), y=c(centroid[2], centroid[2] + setosa_eigenvec_sc[2, 2]), col = &quot;red&quot;, lwd = 4) # vecteur propre 1 points(x=centroid[1], y=centroid[2], pch = 16, cex = 2, col =&quot;blue&quot;) # centroid On peut observer que, comme je lâ€™ai mentionnÃ© plus haut, les vecteurs propres indiquent lâ€™orientation de la covariance, et les valeurs propres indique la longueur associÃ©e Ã  cette direction. 8.4.1.1.2 Biplot Imaginez un nuage de points en 3D, axes y compris. Vous tournez votre nuage de points pour trouver la perspective en 2D qui fera en sorte que vos donnÃ©es soient les plus dispersÃ©es possibles. Avec une lampe de poche, vous illuminez votre nuage de points dans lâ€™axe de cette perspective: vous venez dâ€™effectuer une analyse en composantes principales, et lâ€™ombre des points et des axes sur le mur formera votre biplot. Pour crÃ©er un biplot, on juxtapose les descripteurs (variables) en tant que vecteurs propres, reprÃ©sentÃ©s par des flÃ¨ches, et les objets (observations) en tant que scores, reprÃ©sentÃ©s par des points. Les rÃ©sultats dâ€™une ordination peuvent Ãªtre prÃ©sentÃ©s selon deux types de biplots (Legendre et Legendre, 2012). Biplot de corrÃ©lation permettant de visualiser les corrÃ©lations entre des variables mÃ©tÃ©orologiques. Source: Parent, 2017 Deux types de projection sont courramment utilisÃ©s. Biplot de distance. Ce type de projection permet de visualiser la position des objets entre eux et par rapport aux descripteurs et dâ€™apprÃ©cier la contribution des descripteurs pour crÃ©er les composantes principales. Pour crÃ©er un biplot de distance, on projette directement les vecteurs propres (\\(U\\)) en guise de descripteurs. Pour ce qui est des objets, on utilise les scores de lâ€™ACP (\\(F\\)). De cette maniÃ¨re, les distances euclidiennes entre les scores sont des approximations des distances euclidiennes dans lâ€™espace multidimentionnel, la projection dâ€™un objet sur un descripteur perpendiculairement Ã  ce dernier est une approximation de la position de lâ€™objet sur le descripteur et la projection dâ€™un descripteur sur un axe principal est proportionnelle Ã  sa contribution pour gÃ©nÃ©rer lâ€™axe. Biplot de corrÃ©lation. Cette projection permet dâ€™apprÃ©cier les corrÃ©lations entre les descripteurs. Pour ce faire, les objets et les valeurs propres doivent Ãªtre transformÃ©s. Pour gÃ©nÃ©rer les descripteurs, les vecteurs propres (\\(U\\)) doivent Ãªtre multipliÃ©s par la matrice diagonalisÃ©e de la racine carrÃ©e des valeurs propres (\\(\\Lambda\\)), câ€™est-Ã -dire \\(U \\Lambda ^{\\frac{1}{2}}\\). En ce qui a trait aux objets, on multiplie les scores par (\\(F\\)) par la racine carrÃ©e nÃ©gative des valeurs propres diagonalisÃ©es, câ€™est-Ã -dire \\(F \\Lambda ^{- \\frac{1}{2}}\\). De cette maniÃ¨re, tout comme câ€™est le cas pour le biplot de distance, la projection dâ€™un objet sur un descripteur perpendiculairement Ã  ce dernier est une approximation de la position de lâ€™objet sur le descripteur, la projection dâ€™un descripteur sur un axe principal est proportionnelle Ã  son Ã©cart-type et les angles entre les descripteurs sont proportionnelles Ã  leur corrÃ©lation (et non pas leur proximitÃ©). En dâ€™autres mots, le bilot de distances devrait Ãªtre utilisÃ© pour apprÃ©cier la distance entre les objets et le biplot de corrÃ©lation devrait Ãªtre utilisÃ© pour apprÃ©cier les corrÃ©lations entre les descripteurs. Mais dans tous les cas, le type de biplot utilisÃ© doit Ãªtre indiquÃ©. Le triplot est une forme apparentÃ©e au biplot, auquel on ajoute des variables prÃ©dictives. Le triplot est utile pour reprÃ©senter les rÃ©sultats des ordinations contraignantes comme les analyses de redondance et les analyse de correspondance canoniques. 8.4.1.1.3 Application Bien que lâ€™ACP puisse Ãªtre effectuÃ©e grÃ¢ce Ã  des modules de base de R, nous utiliserons le module vegan. Le tableau varechem comprend des donnÃ©es issues dâ€™analyse de sols identifiÃ©s par leur composition chimique, leur pH, leur profondeur totale et la profondeur de lâ€™humus publiÃ©es dans VÃ¤re et al. (1995) et exportÃ©es du module vegan. library(&quot;vegan&quot;) data(&quot;varechem&quot;) varechem %&gt;% sample_n(5) ## N P K Ca Mg S Al Fe Mn Zn Mo Baresoil ## 1 24.2 31.0 138.2 394.6 45.3 27.1 74.2 9.8 24.4 5.2 0.3 29.8 ## 2 19.8 42.1 139.9 519.4 90.0 32.3 39.0 40.9 58.1 4.5 0.3 43.9 ## 3 19.1 26.4 61.1 259.1 37.0 21.4 155.1 81.4 20.6 4.0 0.6 5.8 ## 4 26.2 61.9 202.2 741.2 86.3 48.6 124.3 23.6 94.5 10.2 0.6 56.9 ## 5 22.8 50.6 151.7 648.0 64.8 30.2 12.1 2.3 122.9 8.1 0.2 23.7 ## Humdepth pH ## 1 2.0 2.8 ## 2 2.2 2.7 ## 3 1.9 3.0 ## 4 2.5 2.9 ## 5 2.6 2.9 Comme nous lâ€™avons vu prÃ©cdemment, les donnÃ©es de concentration sont de type compositionnelles. Les donnÃ©es compositionnelles du tableau varechem mÃ©riteraient dâ€™Ãªtre transformÃ©es (Aitchison et Greenacre, 2002). Utilisons les log-ratios centrÃ©s (clr). library(&quot;compositions&quot;) ## Loading required package: tensorA ## ## Attaching package: &#39;tensorA&#39; ## The following object is masked from &#39;package:base&#39;: ## ## norm ## Loading required package: robustbase ## Loading required package: energy ## Loading required package: bayesm ## Welcome to compositions, a package for compositional data analysis. ## Find an intro with &quot;? compositions&quot; ## ## Attaching package: &#39;compositions&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## cor, cov, dist, var ## The following objects are masked from &#39;package:base&#39;: ## ## %*%, scale, scale.default varecomp &lt;- varechem %&gt;% select(-Baresoil, -Humdepth, -pH) %&gt;% mutate(Fv = apply(., 1, function(x) 1e6 - sum(x))) vareclr &lt;- varecomp %&gt;% acomp(.) %&gt;% clr(.) %&gt;% as_tibble() %&gt;% bind_cols(varechem %&gt;% select(Baresoil, Humdepth, pH)) ## Warning: Calling `as_tibble()` on a vector is discouraged, because the behavior is likely to change in the future. Use `enframe(name = NULL)` instead. ## This warning is displayed once per session. vareclr %&gt;% sample_n(5) ## # A tibble: 5 x 15 ## N P K Ca Mg S Al Fe Mn Zn Mo ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -1.02 -0.187 1.01 2.47 0.649 -0.509 -0.999 -3.09 -0.272 -2.30 -5.39 ## 2 -0.860 -0.822 0.00250 1.09 -0.337 -1.06 1.42 1.02 -1.64 -3.34 -4.99 ## 3 -1.78 -0.613 0.354 1.72 -0.174 -0.645 0.932 -1.02 -0.935 -2.31 -4.85 ## 4 -1.76 -0.553 0.565 2.11 0.575 -0.706 0.159 -1.20 -1.30 -1.95 -4.99 ## 5 -1.27 -0.187 1.16 2.43 0.551 -0.589 -1.56 -2.81 0.588 -1.92 -5.90 ## # â€¦ with 4 more variables: Fv &lt;dbl&gt;, Baresoil &lt;dbl&gt;, Humdepth &lt;dbl&gt;, ## # pH &lt;dbl&gt; Effectuons lâ€™ACP. Pour cet exemple, nous standardiserons les donnÃ©es Ã©tant donnÃ©es que les colonnes Baresoil, Humedepth et pH ne sont pas Ã  la mÃªme Ã©chelle que les colonnes des clr. vareclr_sc &lt;- scale(vareclr) vare_pca &lt;- rda(vareclr_sc) # ou bien rda(vareclr, scale = TRUE, mais la mise Ã  l&#39;Ã©chelle prÃ©alable est plus explicite) Lâ€™objet vareclr_pca contient lâ€™information nÃ©cessaire pour mener notre ACP. summary(vare_pca, scaling = 2) # scaling = 2 pour obtenir les infos pour les biplots de corrÃ©lation ## ## Call: ## rda(X = vareclr_sc) ## ## Partitioning of variance: ## Inertia Proportion ## Total 15 1 ## Unconstrained 15 1 ## ## Eigenvalues, and their contribution to the variance ## ## Importance of components: ## PC1 PC2 PC3 PC4 PC5 PC6 PC7 ## Eigenvalue 7.1523 2.4763 2.1122 0.93015 0.57977 0.48786 0.36646 ## Proportion Explained 0.4768 0.1651 0.1408 0.06201 0.03865 0.03252 0.02443 ## Cumulative Proportion 0.4768 0.6419 0.7827 0.84473 0.88338 0.91590 0.94034 ## PC8 PC9 PC10 PC11 PC12 PC13 ## Eigenvalue 0.29432 0.19686 0.15434 0.107357 0.095635 0.042245 ## Proportion Explained 0.01962 0.01312 0.01029 0.007157 0.006376 0.002816 ## Cumulative Proportion 0.95996 0.97308 0.98337 0.990527 0.996902 0.999719 ## PC14 ## Eigenvalue 0.0042200 ## Proportion Explained 0.0002813 ## Cumulative Proportion 1.0000000 ## ## Scaling 2 for species and site scores ## * Species are scaled proportional to eigenvalues ## * Sites are unscaled: weighted dispersion equal on all dimensions ## * General scaling constant of scores: 4.309777 ## ## ## Species scores ## ## PC1 PC2 PC3 PC4 PC5 PC6 ## N 0.1437 0.7606 -0.6792 0.19837 0.1128526 -0.050149 ## P 0.8670 -0.3214 -0.2950 -0.22940 0.1437960 -0.042884 ## K 0.9122 -0.3857 0.2357 0.03469 0.2737020 0.075717 ## Ca 0.9649 -0.3362 -0.2147 0.17757 -0.2188717 0.008051 ## Mg 0.8263 -0.2723 0.1035 0.52135 -0.1495399 -0.342214 ## S 0.8825 -0.3169 0.3539 -0.21216 0.1176279 -0.191386 ## Al -1.0105 -0.2442 0.2146 0.02674 -0.1005560 -0.043569 ## Fe -1.0338 -0.2464 0.1492 0.13162 0.1512218 0.081571 ## Mn 0.9556 0.1041 -0.1256 -0.21300 0.2565831 0.275275 ## Zn 0.7763 -0.1031 -0.3123 -0.36493 -0.5665691 0.153089 ## Mo -0.2152 0.8717 0.4065 -0.33643 -0.2134335 -0.167725 ## Fv 0.2360 0.5776 -0.8112 0.12736 0.1280097 -0.109737 ## Baresoil 0.5147 0.4210 0.4472 0.54980 -0.1438570 0.463148 ## Humdepth 0.7455 0.4379 0.5194 0.16493 0.0004757 -0.273056 ## pH -0.5754 -0.5864 -0.5957 0.23408 -0.1517661 -0.056641 ## ## ## Site scores (weighted sums of species scores) ## ## PC1 PC2 PC3 PC4 PC5 PC6 ## sit1 0.16862 0.423777 0.46731 0.91175 1.10380 1.06421 ## sit2 -0.09705 -0.097482 0.61143 -0.29049 1.14916 0.40622 ## sit3 0.02831 -0.795737 0.74176 -0.19097 -2.43337 -0.81762 ## sit4 1.39081 -0.354376 -0.19377 -0.45160 0.46020 -0.31446 ## sit5 1.30346 0.357866 0.29887 0.76856 0.20913 -0.64145 ## sit6 0.43636 0.495037 1.21722 1.18128 -0.98242 -0.74474 ## sit7 1.07306 0.467575 -0.32245 0.03717 0.13956 -0.64972 ## sit8 0.02545 0.659714 -0.28861 -0.01424 0.47105 0.45173 ## sit9 1.42005 0.007356 -0.29000 -0.78474 0.97592 -0.80263 ## sit10 -0.50638 -0.220909 1.52981 0.26289 0.42135 0.94054 ## sit11 0.45392 0.649297 0.44573 -0.26620 -0.74522 -0.53228 ## sit12 0.18623 0.259640 0.89112 0.21096 -0.51393 2.24361 ## sit13 1.26264 0.225744 -0.96668 -0.69334 0.61990 0.43312 ## sit14 -1.48685 0.739545 -0.20926 1.09256 0.61856 -0.87999 ## sit15 -0.50622 1.108685 -2.61287 -1.00433 -1.35383 1.21964 ## sit16 -1.28653 0.898663 -0.38778 -0.47556 -0.02449 -0.29419 ## sit17 -1.72773 0.476962 -0.48878 0.71156 1.06398 -1.33473 ## sit18 -0.82844 -0.296515 1.20315 -1.49821 -0.18330 1.05231 ## sit19 -1.00247 -0.609253 0.25185 -0.85420 0.71031 0.14854 ## sit20 -0.43405 -0.338912 0.55348 -1.35776 -0.81986 -1.02468 ## sit21 -0.05083 0.122645 -0.04611 -0.56047 -0.26151 -0.98053 ## sit22 0.17891 -2.315489 -0.69084 -0.19547 0.80628 0.04291 ## sit23 -0.46443 -2.592018 -1.21615 1.56359 -0.62334 0.28748 ## sit24 0.46316 0.728185 -0.49843 1.89726 -0.80791 0.72671 La deuxiÃ¨me ligne de Importance of components, Proportion Explained, indique la proportion de la variance totale captÃ©e successivement par les axes principaux. Le premier axe principal comporte 47.68% de la variance. Le deuxiÃ¨me axe principal ajoutant une proportion de 16,51%, une reprÃ©sentation en deux axes principaux prÃ©sentent 64.19 % de la variance. prop_expl &lt;- vare_pca$CA$eig / sum(vare_pca$CA$eig) prop_expl ## PC1 PC2 PC3 PC4 PC5 ## 0.4768180610 0.1650859388 0.1408156459 0.0620101490 0.0386511040 ## PC6 PC7 PC8 PC9 PC10 ## 0.0325238535 0.0244303815 0.0196215021 0.0131238464 0.0102890284 ## PC11 PC12 PC13 PC14 ## 0.0071571089 0.0063756951 0.0028163495 0.0002813359 La dÃ©cision du nombre dâ€™axes principaux Ã  retenir est arbitraire. Elle peut dÃ©pendre dâ€™un nombre maximal de paramÃ¨tre Ã  retenir pour Ã©viter de surdimensionner un modÃ¨le (curse of dimensionality, section 11) ou dâ€™un seuil de pourcentage de variance minimal Ã  retenir, par exemple 75%. Ou bien, vous retiendrez deux composantes principales si vous dÃ©sirez prÃ©senter un seul biplot. Lâ€™approche de Kaiser-Guttmann (Borcard et al., 2011) consiste Ã  sÃ©lectionner les composantes principales dont la valeur propre est supÃ©rieure Ã  leur moyenne. plot(x = 1:length(vare_pca$CA$eig), y = vare_pca$CA$eig, type = &quot;b&quot;, xlab = &quot;Rang de la valeur propre&quot;, ylab = &quot;Valeur propre&quot;) abline(h = mean(vare_pca$CA$eig), col = &quot;red&quot;, lty = 2) Lâ€™approche du broken stick consiste Ã  couper un bÃ¢ton dâ€™une longueur de 1 en n tranches. La premiÃ¨re tranche est de longueur \\(\\frac{1}{n}\\). La tranche suivante est dâ€™une longueur de la tranche prÃ©cÃ©dente Ã  laquelle on aditionne \\(\\frac{1}{longueur~restante}\\). Puis on place les longueurs en ordre dÃ©croissant. On retient les composantes principales dont les valeurs propres cumulÃ©es sont plus grandes que le broken stick. broken_stick &lt;- function(x) { bsm &lt;- vector(&quot;numeric&quot;, length = x) bsm[1] &lt;- 1/x for (i in 2:x) { bsm[i] &lt;- bsm[i-1] + 1/(x+1-i) } bsm &lt;- rev(bsm/x) return(bsm) } Le graphique du broken stick: plot(x = 1:length(vare_pca$CA$eig), y = prop_expl, type = &quot;b&quot;, xlab = &quot;Rang de la valeur propre&quot;, ylab = &quot;Valeur propre&quot;) lines(x = 1:length(vare_pca$CA$eig), y = broken_stick(length(vare_pca$CA$eig)), col = &quot;red&quot;, lty = 2) Les approches Kaiser-Guttmann et broken stick suggÃ¨rent que les trois premiÃ¨res composantes sont suffisantes pour dÃ©crire la dispersion des donnÃ©es. Examinons les loadings (vecteurs propres) plus en particulier. Dans le langage du module vegan, les vecteurs propres sont les espÃ¨ces (species) et les scores sont les sites. vare_eigenvec &lt;- scores(vare_pca, scaling = 2, display = &quot;species&quot;, choices = 1:(ncol(vareclr)-1)) vare_eigenvec ## PC1 PC2 PC3 PC4 PC5 ## N 0.1437343 0.7606006 -0.6792046 0.1983670 0.1128526122 ## P 0.8669892 -0.3213683 -0.2949864 -0.2294036 0.1437959857 ## K 0.9122089 -0.3857245 0.2356904 0.0346904 0.2737019601 ## Ca 0.9648855 -0.3361651 -0.2147486 0.1775746 -0.2188716732 ## Mg 0.8263327 -0.2723055 0.1035276 0.5213484 -0.1495399242 ## S 0.8824519 -0.3169039 0.3538854 -0.2121562 0.1176278503 ## Al -1.0105173 -0.2441785 0.2145614 0.0267422 -0.1005559874 ## Fe -1.0337676 -0.2463987 0.1491865 0.1316173 0.1512218115 ## Mn 0.9555632 0.1041030 -0.1256178 -0.2130047 0.2565830557 ## Zn 0.7763480 -0.1030878 -0.3122919 -0.3649341 -0.5665691228 ## Mo -0.2152399 0.8717229 0.4064967 -0.3364279 -0.2134335302 ## Fv 0.2360040 0.5775863 -0.8111953 0.1273582 0.1280096553 ## Baresoil 0.5147445 0.4209983 0.4472351 0.5497950 -0.1438569673 ## Humdepth 0.7455213 0.4379436 0.5193895 0.1649306 0.0004756685 ## pH -0.5753858 -0.5863743 -0.5957495 0.2340826 -0.1517660977 ## PC6 PC7 PC8 PC9 PC10 ## N -0.050148980 -0.09111164 -0.06122008 0.315645453 0.08090232 ## P -0.042883754 0.26894062 0.34111276 0.021124287 0.08756299 ## K 0.075717162 -0.21662612 -0.01641260 0.143099440 -0.08737113 ## Ca 0.008050762 0.03630015 0.04775616 -0.073609828 -0.10601799 ## Mg -0.342213793 0.04617838 -0.12098602 -0.051599273 0.18373857 ## S -0.191386377 -0.26825994 0.15822845 0.038378858 0.05100717 ## Al -0.043569364 -0.22737412 0.10598673 0.040586196 -0.14473132 ## Fe 0.081571443 0.10553041 -0.09254655 -0.079426433 0.09908706 ## Mn 0.275275174 0.20224538 -0.19347804 -0.038859808 -0.07637994 ## Zn 0.153089144 -0.12332232 -0.14862229 0.024026151 0.02643462 ## Mo -0.167725160 0.13788948 0.17165900 0.032981311 0.01419924 ## Fv -0.109737235 -0.20911147 0.11289753 -0.281443886 -0.08391004 ## Baresoil 0.463148072 -0.02103009 0.23028292 0.004554036 0.02604286 ## Humdepth -0.273056212 0.17061078 -0.11310394 0.027515405 -0.23068827 ## pH -0.056640816 0.19890884 0.12152266 0.150118818 -0.15240317 ## PC11 PC12 PC13 PC14 ## N -0.019251478 0.045420621 0.05020956 0.002340519 ## P -0.045741546 0.145128883 -0.03337551 -0.010109130 ## K 0.183005607 0.002260341 -0.10566808 0.001169065 ## Ca 0.161460554 0.041210064 0.14341793 0.007419161 ## Mg -0.009862571 -0.063493608 -0.03782662 -0.023575986 ## S -0.138785063 -0.117144869 0.06075094 0.025874035 ## Al -0.089462074 0.058212507 0.01983102 -0.037901576 ## Fe -0.006376211 0.049837173 -0.01169516 0.036048221 ## Mn -0.083300112 -0.133353213 0.02679781 -0.021373612 ## Zn -0.064973307 0.051057277 -0.06538348 0.010896560 ## Mo 0.128814989 -0.114803631 -0.01989539 -0.001335923 ## Fv -0.012456867 -0.020157331 -0.05448619 0.005707928 ## Baresoil -0.061147847 -0.019696758 -0.01640490 0.003823725 ## Humdepth -0.102189307 0.109293684 -0.02485030 0.016559206 ## pH -0.037691048 -0.153813168 -0.04523353 0.014193061 ## attr(,&quot;const&quot;) ## [1] 4.309777 Lâ€™ordre dâ€™importance des vecteurs propres est Ã©tabli en ordre croissant des Ã©lÃ©ment des vecteurs propres associÃ©es. Un vecteur propre est une combinaison linÃ©aire des variables. Par exemple, le premier vecteur propre pointe surtout dans la direction du Fe (-1.497) et de lâ€™Al (-1.463). Le deuxiÃ¨me pointe surtout vers le Mo (2.145). Les vecteurs (loadings) dâ€™un biplot de distance prÃ©sentant les des deux premiÃ¨res composantes principales prendront les coordonnÃ©es des deux premiÃ¨res colonnes. Le vecteur Al aura la coordonnÃ©e [-1.463 ; -0.601], le vecteur de Fe sera placÃ© Ã  [-1.497 ; -0.606] et le vecteur Mo Ã  [-0.312 ; 2.145]. Il existe diffÃ©rentes fonctions dâ€™affichage des biplots. Notez que leur longueur peut Ãªtre magnifiÃ©e pour amÃ©liorer la visualisation. LanÃ§ons la fonction biplot pour crÃ©er un biplot de distance et un autre de corrÃ©lation. par(mfrow = c(1, 2)) biplot(vare_pca, scaling = 1, main = &quot;Biplot de distance&quot;) biplot(vare_pca, scaling = 2, main = &quot;Biplot de corrÃ©lation&quot;) Le biplot de distance permet de dÃ©gager les variables qui expliquent davantage la variabilitÃ© dans notre tableau: les clr du Fe et de lâ€™Al forment en grande partie le premier axe principal, alors que le clr du Mo forme en grande partie le second axe. Le biplot de corrÃ©lation montre que les clr du Fe et du Al sont corrÃ©lÃ©s dans le mÃªme sens, mais das le sens contraire du clr du Mn. Lâ€™information sur la teneur en Fe et celle de lâ€™Al est en grande partie redondante. Toutefois, le clr du Mo est presque indÃ©pendant du clr du Fe, ceux-ci Ã©tant Ã  angle presque droit (~90Â°). Ces relations peuvent Ãªtre explorÃ©es directement. par(mfrow = c(1, 2)) plot(vareclr$Al, vareclr$Fe) plot(vareclr$Mo, vareclr$Fe) Nous avons mentionnÃ© que lâ€™ACP est une rotation. Prenons un second exemple pour bien en saisir les tenants et aboutissants. Le tableau de donnÃ©es que nous chargerons provient dâ€™un infographie dâ€™un dauphin, intitullÃ©e Bottlenose Dolphin, conÃ§u par lâ€™artiste Tarnyloo. Les points correspondent Ã  la surface dâ€™un dauphin. Jâ€™ai ajoutÃ© une colonne anatomy, qui indique Ã  quelle partie anatomique le point appartient. dolphin &lt;- read_csv(&quot;data/07_dolphin.csv&quot;) ## Parsed with column specification: ## cols( ## x = col_double(), ## y = col_double(), ## z = col_double(), ## anatomy = col_character() ## ) dolphin %&gt;% sample_n(5) ## # A tibble: 5 x 4 ## x y z anatomy ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 0.163 -0.382 -0.00500 Head ## 2 0.106 -0.444 -0.0987 Head ## 3 0.0665 -0.547 -0.102 Head ## 4 0.179 -0.305 -0.00840 Head ## 5 0.0770 -0.392 -0.0444 Head Voici en vue isomÃ©trique ce en quoi consiste ce nuage de points. library(&quot;scatterplot3d&quot;) scatterplot3d(x = dolphin$x, y = dolphin$y, z = dolphin$z, pch = 16, cex.symbols = 0.2) Effectuons lâ€™ACP sur le dauphin. dolph_pca &lt;- rda(dolphin %&gt;% select(x, y, z), scale = FALSE) biplot(dolph_pca, scaling = 2) On nâ€™y voit pas grand chose, mais si lâ€™on extrait les scores et que lâ€™on raccourcit les vecteurs: dolph_scores &lt;- scores(dolph_pca, display = &quot;sites&quot;) dolph_loads &lt;- scores(dolph_pca, display = &quot;species&quot;) dolph_loads ## PC1 PC2 ## x -0.02990131 0.01608095 ## y -7.13731672 -1.43221776 ## z -4.56612084 2.23859843 ## attr(,&quot;const&quot;) ## [1] 9.089026 plot(dolph_scores, pch = 16, cex = 0.2, asp = 1) segments(x0 = rep(0, 3), y0 = rep(0, 3), x = dolph_loads[, 1]/50, y = dolph_loads[, 2]/50, col = &quot;red&quot;, lwd = 4) La meilleure reprÃ©sentation du dauphin en 2D, selon la variance, est son profil - en effet, il est plus long et haut que large. Note. Une ACP effectue seulement une rotation des points. Les distances euclidiennes entre les points sont maintenues. Note. Lâ€™ACP a Ã©tÃ© conÃ§ue pour projetter en un nombre moindre de dimensions des observations dont les distributions sont multinormales (ce nâ€™est Ã©videmment pas le cas du dauphin). Note. Les axes principaux dâ€™une ACP sont des variables alÃ©atoires. Elles peuvent Ãªtre assujetties Ã  des tests ststistiques, des modÃ¨les, du partitionnement de donnÃ©es, etc. "]
]
