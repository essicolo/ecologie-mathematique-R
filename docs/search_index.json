[
["chapitre-tableaux.html", "3 Organisation des données et opérations sur des tableaux 3.1 Les collections de données 3.2 Organiser un tableau de données 3.3 Formats de tableau 3.4 Entreposer ses données 3.5 Manipuler des données en mode tidyverse 3.6 Références", " 3 Organisation des données et opérations sur des tableaux ️ Objectifs spécifiques: À la fin de ce chapitre, vous comprendrez les règles guidant la création et la gestion des tableaux, saurez importer et exporter des données et saurez effectuer des opérations en cascade avec le module tidyverse, dont des filtres sur les lignes, des sélections de colonnes, des sommaires statistiques et des jointures entre tableaux. Les données sont utilisées à chaque étape dans les flux de travail en sciences. Elles alimentent l’analyse et la modélisation. Les résultats qui en découlent sont aussi des données qui peuvent alimenter les travaux subséquents. Une bonne organisation des données facilitera le flux de travail. Dicton. Proportions de temps voué aux calcul scientifique: 80% de nettoyage de données mal organisées, 20% de calcul. Qu’est-ce qu’une donnée? De manière abstraite, il s’agit d’une valeur associée à une variable. Une variable peut être une dimension, une date, une couleur, le résultat d’un test statistique, à laquelle on attribue la valeur quantitative ou qualitative d’un chiffre, d’une chaîne de caractère, d’un symbole conventionné, etc. Par exemple, lorsque vous commandez un café latte végane, au latte est la valeur que vous attribuez à la variable type de café, et végane est la valeur de la variable type de lait. L’exemple est peut-être horrible. J’ai besoin d’un café… Ce chapitre traite de l’importation, l’utilisation et l’exportation de données structurées, en R, sous forme de vecteurs, matrices, tableaux et ensemble de tableaux (bases de données). Bien qu’il soit toujours préférable d’organiser les structures qui accueilleront les données d’une expérience avant-même de procéder à la collecte de données, l’analyste doit s’attendre à réorganiser ses données en cours de route. Or, des données bien organisées au départ faciliteront aussi leur réorganisation. Ce chapitre débute avec quelques définitions: les données, les matrices, les tableaux et les bases de données, ainsi que leur signification en R. Puis nous verrons comment organiser un tableau selon quelques règles simples, mais importantes pour éviter les erreurs et les opérations fastidieuses pour reconstruire un tableau mal conçu. Ensuite, nous traiterons des formats de tableau courant, pour enfin passer à l’utilisation de dplyr, le module tidyverse pour effectuer des opérations sur les tableaux. 3.1 Les collections de données Dans le chapitre 2, nous avons survolé différents types d’objets: réels, entiers, chaînes de caractères et booléens. Les données peuvent appartenir à d’autres types: dates, catégories ordinales (ordonnées: faible, moyen, élevé) et nominales (non ordonnées: espèces, cultivars, couleurs, unité pédologique, etc.). Comme mentionné en début de chapitre, une donnée est une valeur associée à une variable. Les données peuvent être organisées en collections. Nous avons aussi vu au chapitre 2 que la manière privilégiée d’organiser des données était sous forme de tableau. De manière générale, un tableau de données est une organisation de données en deux dimensions, comportant des lignes et des colonnes. Il est préférable de respecter la convention selon laquelle les lignes sont des observations et les colonnes sont des variables. Ainsi, un tableau est une collection de vecteurs de même longueur, chaque vecteur représentant une variable. Chaque variable est libre de prendre le type de données approprié. La position d’une donnée dans le vecteur correspond à une observation. Imaginez que vous consignez des données de différents sites (A, B et C), et que chaque site possède ses propres caractéristiques. Il est redondant de décrire le site pour chaque observation. Vous préférerez créer deux tableaux: un pour décrire vos observations, et un autre pour décrire les sites. De cette manière, vous créez une collection de tableaux intereliés: une base de données. R peut soutirer des données des bases de données grâce au module DBI, qui n’est pas couvert à ce stade de développement du cours. Dans R, les données structurées en tableaux, ainsi que les opérations sur les tableaux, peuvent être gérés grâce aux modules readr, dplyr et tidyr, tous des modules faisant partie du méta-module tidyverse, devenu incontoutnable. Mais avant de se lancer dans l’utilisation de ces modules, voyons quelques règles à suivre pour bien structurer ses données en format tidy, un jargon du tidyverse qui signifie proprement organisé. 3.2 Organiser un tableau de données Afin de repérer chaque cellule d’un tableau, on attribue à chaque lignes et à chaque colonne colonnes un identifiant unique, que l’on nomme indice pour les lignes et entête pour les colonnes. Règle no 1. Une variable par colonne, une observation par ligne, une valeur par cellule. Les unités expérimentales sont décrits par une ou plusieurs variables par des chiffres ou des lettres. Chaque variable devrait être présente en une seule colonne, et chaque ligne devrait correspondre à une unité expérimentale où ces variables ont été mesurées. La règle parait simple, mais elle est rarement respectée. Prenez par exemple le tableau suivant. Site Traitement A Traitement B Traitement C Sainte-Souris 4.1 8.2 6.8 Sainte-Fourmi 5.8 5.9 NA Saint-Ours 2.9 3.4 4.6 Tableau 1. Rendements obtenus sur les sites expérimentaux selon les traitements. Qu’est-ce qui cloche avec ce tableau? Chaque ligne est une observation, mais contient plusieurs observations d’une même variable, le rendement, qui devient étalé sur plusieurs colonnes. À bien y penser, le type de traitement est une variable et le rendement en est une autre: Site Traitement Rendement Sainte-Souris A 4.1 Sainte-Souris B 8.2 Sainte-Souris C 6.8 Sainte-Fourmi A 5.8 Sainte-Fourmi B 5.9 Sainte-Fourmi C NA Saint-Ours A 2.9 Saint-Ours B 3.4 Saint-Ours C 4.6 Tableau 2. Rendements obtenus sur les sites expérimentaux selon les traitements. Plus précisément, l’expression à bien y penser suggère une réflexion sur la signification des données. Certaines variables peuvent parfois être intégrées dans une même colonne, parfois pas. Par exemple, les concentrations en cuivre, zinc et plomb dans un sol contaminé peuvent être placés dans la même colonne “Concentration” ou déclinées en plusieurs colonnes Cu, Zn et Pb. La première version trouvera son utilité pour des créer des graphiques (chapitre 3), alors que la deuxième favorise le traitement statistique (chapitre 5). Il est possible de passer d’un format à l’autre grâce à la fonction pivot_longer() et pivot_wider() du module tidyr. Règle no 2. Un tableau par unité observationnelle: ne pas répéter les informations. Reprenons la même expérience. Supposons que vous mesurez la précipitation à l’échelle du site. Site Traitement Rendement Précipitations Sainte-Souris A 4.1 813 Sainte-Souris B 8.2 813 Sainte-Souris C 6.8 813 Sainte-Fourmi A 5.8 642 Sainte-Fourmi B 5.9 642 Sainte-Fourmi C NA 642 Saint-Ours A 2.9 1028 Saint-Ours B 3.4 1028 Saint-Ours C 4.6 1028 Tableau 3. Rendements obtenus sur les sites expérimentaux selon les traitements. Segmenter l’information en deux tableaux serait préférable. Site Précipitations Sainte-Souris 813 Sainte-Fourmi 642 Saint-Ours 1028 Tableau 4. Précipitations sur les sites expérimentaux. Les tableaux 2 et 4, ensemble, forment une base de données (collection organisée de tableaux). Les opérations de fusion entre les tableaux peuvent être effectuées grâce aux fonctions de jointure (left_join(), par exemple) du module tidyr. Règle no 3. Ne pas bousiller les données. Par exemple. Ajouter des commentaires dans des cellules. Si une cellule mérite d’être commentée, il est préférable de placer les commentaires soit dans un fichier décrivant le tableau de données, soit dans une colonne de commentaire juxtaposée à la colonne de la variable à commenter. Par exemple, si vous n’avez pas mesure le pH pour une observation, n’écrivez pas “échantillon contaminé” dans la cellule, mais annoter dans un fichier d’explication que l’échantillon no X a été contaminé. Si les commentaires sont systématique, il peut être pratique de les inscrire dans une colonne commentaire_pH. Inscription non systématiques. Il arrive souvent que des catégories d’une variable ou que des valeurs manquantes soient annotées différemment. Il arrive même que le séparateur décimal soit non systématique, parfois noté par un point, parfois par une virgule. Par exemple, une fois importés dans votre session, les catégories St-Ours et Saint-Ours seront traitées comme deux catégories distinctes. De même, les cellules correspondant à des valeurs manquantes ne devraient pas être inscrite parfois avec une cellule vide, parfois avec un point, parfois avec un tiret ou avec la mention NA. Le plus simple est de laisser systématiquement ces cellules vides. Inclure des notes dans un tableau. La règle “une colonne, une variable” n’est pas respectée si on ajoute des notes un peu n’importe où sous ou à côté du tableau. Ajouter des sommaires. Si vous ajoutez une ligne sous un tableau comprenant la moyenne de chaque colonne, qu’est-ce qui arrivera lorsque vous importerez votre tableau dans votre session de travail? La ligne sera considérée comme une observation supplémentaire. Inclure une hiérarchie dans le entêtes. Afin de consigner des données de texture du sol, comprenant la proportion de sable, de limon et d’argile, vous organisez votre entête en plusieurs lignes. Une ligne pour la catégorie de donnée, Texture, fusionnée sur trois colonnes, puis trois colonnes intitulées Sable, Limon et Argile. Votre tableau est joli, mais il ne pourra pas être importé conformément dans un votre session de calcul: on recherche une entête unique par colonne. Votre tableau de données devrait plutôt porter les entêtes Texture sable, Texture limon et Texture argile. Un conseil: réserver le travail esthétique à la toute fin d’un flux de travail. 3.3 Formats de tableau Plusieurs outils sont à votre disposition pour créer des tableaux. Je vous présente ici les plus communs. 3.3.1 xls ou xlsx Microsoft Excel est un logiciel de type tableur, ou chiffrier électronique. L’ancien format xls a été remplacé par le format xlsx avec l’arrivée de Microsoft Office 2010. Il s’agit d’un format propriétaire, dont l’alternative libre la plus connue est le format ods, popularisé par la suite bureautique LibreOffice. Les formats xls, xlsx ou ods sont davantage utilisés comme outils de calcul que d’entreposage de données. Ils contiennent des formules, des graphiques, du formatage de cellule, etc. Je ne les recommande pas pour stocker des données. 3.3.2 csv Le format csv, pour comma separated values, est un fichier texte, que vous pouvez ouvrir avec n’importe quel éditeur de texte brut (Bloc note, Atom, Notepad++, etc.). Chaque colonne doit être délimitée par un caractère cohérent (conventionnellement une virgule, mais en français un point-virgule ou une tabulation pour éviter la confusion avec le séparateur décimal) et chaque ligne du tableau est un retour de ligne. Il est possible d’ouvrir et d’éditer les fichiers csv dans un éditeur texte, mais il est plus pratique de les ouvrir avec des tableurs (LibreOffice Calc, Microsoft Excel, Google Sheets, etc.). Encodage des fichiers texte. Puisque le format csv est un fichier texte, un souci particulier doit être porté sur la manière dont le texte est encodé. Les caractères accentués pourrait être importer incorrectement si vous importez votre tableau en spécifiant le mauvais encodage. Pour les fichiers en langues occidentales, l’encodage UTF-8 devrait être utilisé. Toutefois, par défaut, Excel utilise un encodage de Microsoft. Si le csv a été généré par Excel, il est préférable de l’ouvrir avec votre éditeur texte et de l’enregistrer dans l’encodage UTF-8. 3.3.3 json Comme le format csv, le format json indique un fichier en texte clair. Il est utilisé davantage pour le partage de données des applications web. En analyse et modélisation, ce format est surtout utilisé pour les données géoréférencées. L’encodage est géré de la même manière qu’un fichier csv. 3.3.4 SQLite SQLite est une application pour les bases de données relationnelles de type SQL qui n’a pas besoin de serveur pour fonctionner. Les bases de données SQLite sont encodés dans des fichiers portant l’extension db, qui peuvent être facilement partagés. 3.3.5 Suggestion En csv pour les petits tableaux, en sqlite pour les bases de données plus complexes. Ce cours se concentre toutefois sur les données de type csv. 3.4 Entreposer ses données La manière la plus sécurisée pour entreposer ses données est de les confiner dans une base de données sécurisée sur un serveur sécurisé dans un environnement sécurisé et d’encrypter les communications. C’est aussi la manière la moins accessible. Des espaces de stockage nuagiques, comme Dropbox ou d’autres options similaires, peuvent être pratiques pour les backups et le partage des données avec une équipe de travail (qui risque en retour de bousiller vos données). Le suivi de version est possible chez certains fournisseurs d’espace de stockage. Mais pour un suivi de version plus rigoureux, les espaces de développement (comme GitHub et GitLab) sont plus appropriés (couverts au chapitre 5). Dans tous les cas, il est important de garder (1) des copies anciennes pour y revenir en cas d’erreurs et (2) un petit fichier décrivant les changements effectués sur les données. 3.5 Manipuler des données en mode tidyverse Le méta-module tidyverse regroupe une collection de précieux modules pour l’analyse de données en R. Il permet d’importer des données dans votre session de travail avec readr, de les explorer avec le module de visualisation ggplot2, de les transformer avec tidyr et dplyr et de les exporter avec readr. Les tableaux de classe data.frame, comme ceux de la plus moderne classe tibble, peuvent être manipulés à travers le flux de travail pour l’analyse et la modélisation (chapitres suivants). Comme c’était le cas pour le chapitre sur la visualisation, ce chapitre est loin de couvrir les nombreuses fonctionnalités qui sont offertes dans le tidyverse. 3.5.1 Importer vos données dans voter session de travail Supposons que vous avec bien organisé vos données en mode tidy. Pour les importer dans votre session et commencer à les inspecter, vous lancerez une des commandes du module readr, décrites dans la documentation dédiée. read_csv() si le séparateur de colonne est une virgule read_csv2() si le séparateur de colonne est un point-virgule et que le séparateur décimal est une virgule read_tsv() si le séparateur de colonne est une tabulation read_table() si le séparateur de colonne est un espace blanc read_delim() si le séparateur de colonne est un autre caractère (comme le point-virgule) que vous spécifierez dans l’argument delim = &quot;;&quot; Les principaux arguments sont les suivants. file: le chemin vers le fichier. Ce chemin peut aussi bien être une adresse locale (data/…) qu’une adresse internet (https://…). delim: le symbole délimitant les colonnes dans le cas de read_delim. col_names: si TRUE, la première ligne est l’entête du tableau, sinon FALSE. Si vous spécifiez un vecteur numérique, ce sont les numéros des lignes utilisées pour le nom de l’entête. Si vous utilisez un vecteur de caractères, ce sont les noms des colonnes que vous désirez donner à votre tableau. na: le symbole spécifiant une valeur manquante. L’argument na='' signifie que les cellules vides sont des données manquantes. Si les valeurs manquantes ne sont pas uniformes, vous pouvez les indiquer dans un vecteur, par exemple na = c(&quot;&quot;, &quot;NA&quot;, &quot;NaN&quot;, &quot;.&quot;, &quot;-&quot;). local: cet argument prend une fonction local() qui peut inclure des arguments de format de temps, mais aussi d’encodage (voir documentation) D’autres arguments peuvent être spécifiés au besoin, et les répéter ici dupliquerait l’information de la documentation de la fonction read_csv de readr. Je déconseille d’importer des données en format xls ou xlsx. Si toutefois cela vous convient, je vous réfère au module readxl. L’aide-mémoire de readr (figure 3.1) est à afficher près de soi. Figure 3.1: Aide-mémoire de readr, Source: https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf Nous allons charger des données de culture de la chicouté (Rubus chamaemorus), un petit fruit nordique, tiré de Parent et al. (2013). Ouvrons d’abord le fichier pour vérifier les séparateurs de colonne et de décimale (figure 3.2). Figure 3.2: Aperçu brut d’un fichier csv. Le séparateur de colonne est un point-virgule et le décimal est une virgule. Avec Atom, mon éditeur texte préféré (il y en a d’autres), je vais dans Edit &gt; Select Encoding et j’obtiens bien le UTF-8 (figure 3.3). Figure 3.3: Changer l’encodage d’un fichier csv. Nous allons donc utiliser read_csv2() avec ses arguments par défaut. library(&quot;tidyverse&quot;) ## ── Attaching packages ───────────────────────────────────────────────────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.2.1 ✓ purrr 0.3.3 ## ✓ tibble 2.1.3 ✓ dplyr 0.8.3 ## ✓ tidyr 1.0.0 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.4.0 ## ── Conflicts ──────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() chicoute &lt;- read_csv2(&#39;data/chicoute.csv&#39;) ## Using &#39;,&#39; as decimal and &#39;.&#39; as grouping mark. Use read_delim() for more control. ## Parsed with column specification: ## cols( ## .default = col_double(), ## CodeTourbiere = col_character(), ## Ordre = col_character(), ## Traitement = col_character(), ## DemiParcelle = col_character(), ## SousTraitement = col_character() ## ) ## See spec(...) for full column specifications. Quelques commandes utiles inspecter le tableau: head() présente l’entête du tableau, soit ses 6 premières lignes str() et glimpse() présentent les variables du tableau et leur type - glimpse()est la fonction tidyverse et str() est la fonction classique (je préfère str()) summary() présente des statistiques de base du tableau names() ou colnames() sort les noms des colonnes sous forme d’un vecteur dim() donne les dimensions du tableau, ncol() son nombre de colonnes et nrow() son nombre de lignes skim est une fonction du module skimr montrant un portrait graphique et numérique du tableau Extra 1. Plusieurs modules ne se trouvent pas dans les dépôt CRAN, mais sont disponibles sur GitHub. Pour les installer, installez d’abord le module devtools disponible sur CRAN. Vous pourrez alors installer les packages de GitHub comme on le fait avec le package skimr. Extra 2. Lorsque je désire utiliser une fonction, mais sans charger le module dans la session, j’utilise la notation module::fonction. Comme dans ce cas, pour skimr. # devtools::install_github(&quot;ropenscilabs/skimr&quot;) skimr::skim(chicoute) Table 3.1: Data summary Name chicoute Number of rows 90 Number of columns 31 _______________________ Column type frequency: character 5 numeric 26 ________________________ Group variables None Variable type: character skim_variable n_missing complete_rate min max empty n_unique whitespace CodeTourbiere 0 1.00 1 4 0 12 0 Ordre 0 1.00 1 2 0 20 0 Traitement 50 0.44 6 11 0 2 0 DemiParcelle 50 0.44 4 5 0 2 0 SousTraitement 50 0.44 1 7 0 3 0 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist ID 0 1.00 45.50 26.12 1.00 23.25 45.50 67.75 90.00 ▇▇▇▇▇ Site 0 1.00 6.33 5.49 1.00 2.00 4.00 9.00 20.00 ▇▃▁▁▁ Latitude_m 0 1.00 5701839.86 1915.50 5695688.00 5701868.50 5702129.00 5702537.00 5706394.00 ▁▂▅▇▁ Longitude_m 0 1.00 485295.54 6452.33 459873.00 485927.00 486500.00 486544.75 491955.00 ▁▁▁▂▇ Rendement_g_5m2 50 0.44 13.33 21.56 0.00 0.00 0.94 15.63 72.44 ▇▁▁▁▁ TotalRamet_nombre_m2 0 1.00 251.26 156.06 40.74 122.70 212.92 347.80 651.90 ▇▇▃▂▂ TotalVegetatif_nombre_m2 4 0.96 199.02 139.13 22.92 86.26 161.25 263.78 580.60 ▇▇▂▂▁ TotalFloral_nombre_m2 4 0.96 52.08 40.41 4.80 22.92 43.00 69.52 198.62 ▇▅▂▁▁ TotalMale_nombre_m2 4 0.96 24.40 26.87 0.00 3.30 15.28 36.51 104.41 ▇▂▂▁▁ TotalFemelle_nombre_m2 4 0.96 27.53 29.83 2.55 10.34 17.19 31.96 187.17 ▇▁▁▁▁ FemelleFruit_nombre_m2 18 0.80 19.97 23.79 0.40 7.64 11.46 22.83 157.88 ▇▂▁▁▁ FemelleAvorte_nombre_m2 4 0.96 8.49 14.52 0.00 1.27 3.07 10.14 76.80 ▇▁▁▁▁ SterileFleur_nombre_m2 4 0.96 0.26 0.71 0.00 0.00 0.00 0.00 3.82 ▇▁▁▁▁ C_pourc 0 1.00 50.28 1.61 46.72 49.14 50.45 51.58 53.83 ▃▆▅▇▁ N_pourc 0 1.00 2.20 0.40 1.53 1.89 2.12 2.58 3.10 ▃▇▃▃▂ P_pourc 0 1.00 0.14 0.04 0.07 0.12 0.14 0.16 0.23 ▃▆▇▂▂ K_pourc 0 1.00 0.89 0.27 0.35 0.69 0.86 1.13 1.54 ▃▇▇▇▁ Ca_pourc 0 1.00 0.39 0.10 0.19 0.32 0.37 0.44 0.88 ▅▇▂▁▁ Mg_pourc 0 1.00 0.50 0.08 0.36 0.45 0.48 0.52 0.86 ▇▇▂▁▁ S_pourc 0 1.00 0.13 0.04 0.07 0.11 0.13 0.14 0.28 ▅▇▂▁▁ B_pourc 0 1.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 ▂▅▃▇▃ Cu_pourc 0 1.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 ▇▁▁▁▁ Zn_pourc 0 1.00 0.01 0.00 0.00 0.01 0.01 0.01 0.02 ▇▇▂▁▁ Mn_pourc 0 1.00 0.03 0.03 0.00 0.01 0.03 0.05 0.10 ▇▅▃▂▁ Fe_pourc 0 1.00 0.02 0.01 0.01 0.01 0.01 0.02 0.05 ▇▂▁▁▁ Al_pourc 0 1.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 ▇▅▁▁▁ Exercice. Inspectez le tableau. 3.5.2 Comment sélectionner et filtrer des données? On utiliser le terme sélectionner lorsque l’on désire choisir une ou plusieurs lignes et colonnes d’un tableau (la plupart du temps des colonnes). L’action de filtrer signifie de sélectionner des lignes selon certains critères. 3.5.2.1 Sélectionner Voici trois manières de sélectionner une colonne en R. Une méthode rapide mais peu expressive consiste à indiquer les valeurs numériques de l’indice de la colonne entre des crochets. Il s’agit d’appeler le tableau suivit de crochets. L’intérieur des crochets comprend deux éléments séparés par une virgule. Le premier élément sert à filtrer selon l’indice, le deuxième sert à sélectionner selon l’indice. Ainsi: chicoute[, 1]: sélectionner la première colonne chicoute[, 1:10]: sélectionner les 10 premières colonnes chicoute[, c(2, 4, 5)]: sélectionner les colonnes 2, 4 et 5 chicoute[c(10, 13, 20), c(2, 4, 5)]: sélectionner les colonnes 2, 4 et 5 et les lignes 10, 13 et 20. Une autre méthode rapide, mais plus expressive, consiste à appeler le tableau, suivi du symbole $, puis le nom de la colonne. Ou bien d’inscrire le nom de la colonne, ou du vecteur des colonnes, entre des crochets suivant le nom du tableau, c’est-à-dire chicoute[c(&quot;Site&quot;, &quot;Latitude_m&quot;, &quot;Longitude_m&quot;)]. Enfin, dans une séquence d’opérations en mode pipeline (chaque opération est mise à la suite de la précédente en plaçant le pipe %&gt;% entre chacune), il peut être préférable de sélectionner des colonnes avec la fonction select(), i.e. chicoute %&gt;% select(Site, Latitude_m, Longitude_m) Truc. La plupart des IDE, comme RStudio, peuvent vous proposer des colonnes dans une liste. Après avoir entrer le $, taper sur la touche de tabulation: vous pourrez sélectionner la colonne dans une liste défilante (figure 3.4). Figure 3.4: Autocomplétion dans RStudio. La fonction select() permet aussi de travailler en exclusion. Ainsi pour enlever des colonnes, on placera un - (signe de soustraction) devant le nom de la colonne. ⚠️ Attention. Plusieurs modules utilisent la fonction select (et filter, plus bas). Lorsque vous lancez select et que vous obtenez un message d’erreur comme Error in select(., ends_with(&quot;pourc&quot;)) : argument inutilisé (ends_with(&quot;pourc&quot;)) il se pourrait bien que R utilise la fonction select d’un autre module. Pour spécifier que vous désirez la fonctionn select du module dplyr, spécifiez dplyr::select. D’autre arguments de select() permettent une sélection rapide. Par exemple, pour obtenir les colonnes contenant des pourcentages: chicoute %&gt;% select(ends_with(&quot;pourc&quot;)) %&gt;% head(3) ## # A tibble: 3 x 13 ## C_pourc N_pourc P_pourc K_pourc Ca_pourc Mg_pourc S_pourc B_pourc Cu_pourc ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 51.5 1.72 0.108 1.21 0.435 0.470 0.0976 0.00258 0.000175 ## 2 51.3 2.18 0.0985 1.22 0.337 0.439 0.0996 0.00258 0.000407 ## 3 50.6 2.12 0.0708 1.05 0.373 0.420 0.104 0.00258 0.000037 ## # … with 4 more variables: Zn_pourc &lt;dbl&gt;, Mn_pourc &lt;dbl&gt;, Fe_pourc &lt;dbl&gt;, ## # Al_pourc &lt;dbl&gt; 3.5.2.2 Filtrer Comme c’est le cas de la sélection, on pourra filtrer un tableau de plusieurs manières. J’ai déjà présenté comment filtrer selon les indices des lignes. Les autres manières reposent néanmoins sur une opération logique ==, &lt;, &gt; ou %in% (le %in% signifie se trouve parmi et peut être suivi d’un vecteur de valeur que l’on désire accepter). Les conditions booléennes peuvent être combinées avec les opérateurs et, &amp;, et ou, |. Pour rappel, Opération Résultat Vrai et Vrai Vrai Vrai et Faux Faux Faux et Faux Faux Vrai ou Vrai Vrai Vrai ou Faux Vrai Faux ou Faux Faux La méthode classique consiste à appliquer une opération logique entre les crochets, par exemple chicoute[chicoute$CodeTourbiere == &quot;BEAU&quot;, ] La méthode tidyverse, plus pratique en mode pipeline, passe par la fonction filter(), i.e. chicoute %&gt;% filter(CodeTourbiere == &quot;BEAU&quot;) Combiner le tout. chicoute %&gt;% filter(Ca_pourc &lt; 0.4 &amp; CodeTourbiere %in% c(&quot;BEAU&quot;, &quot;MB&quot;, &quot;WTP&quot;)) %&gt;% select(contains(&quot;pourc&quot;)) ## # A tibble: 4 x 13 ## C_pourc N_pourc P_pourc K_pourc Ca_pourc Mg_pourc S_pourc B_pourc Cu_pourc ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 51.3 2.18 0.0985 1.22 0.337 0.439 0.0996 0.00258 0.000407 ## 2 50.6 2.12 0.0708 1.05 0.373 0.420 0.104 0.00258 0.000037 ## 3 53.8 2.04 0.115 0.947 0.333 0.472 0.106 0.00258 0.000037 ## 4 52.6 2.11 0.0847 0.913 0.328 0.376 0.111 0.00296 0.000037 ## # … with 4 more variables: Zn_pourc &lt;dbl&gt;, Mn_pourc &lt;dbl&gt;, Fe_pourc &lt;dbl&gt;, ## # Al_pourc &lt;dbl&gt; 3.5.3 Le format long et le format large Dans le tableau chicoute, chaque élément possède sa propre colonne. Si l’on voulait mettre en graphique les boxplot des facettes de concentrations d’azote, de phosphore et de potassium dans les différentes tourbières, il faudrait obtenir une seule colonne de concentrations. Pour ce faire, nous utiliserons la fonction pivot_longer(). L’argument obligatoire (excluant le tableau, qui est implicite dans la chaîne d’opérations), est cols, le nom des colonnes à allonger. Pour obtenir des noms de colonnes allongées personnalisées, on spécifie le nom des variables consistant aux anciens noms de colonnes avec names_to et celui de la nouvelle colonne contenant les valeurs dans values_to. La suite consiste à décrire les colonnes à inclure ou à exclure. Dans le cas qui suit, j’exclue CodeTourbiere de la refonte j’utilise sample_n() pour présenter un échantillon du résultat. Notez la ligne comprenant la fonction mutate, que l’on verra plus loin. Cette fonction ajoute une colonne au tableau. Dans ce cas-ci, j’ajoute une colonne constituée d’une séquence de nombres allant de 1 au nombre de lignes du tableau (il y en a 90). Cet identifiant unique pour chanque ligne permettra de reconstituer par la suite le tableau initial. chicoute_long &lt;- chicoute %&gt;% select(CodeTourbiere, N_pourc, P_pourc, K_pourc) %&gt;% mutate(ID = 1:nrow(.)) %&gt;% # mutate ajoute une colonne au tableau pivot_longer(cols = contains(&quot;pourc&quot;), names_to = &quot;nutrient&quot;, values_to = &quot;concentration&quot;) chicoute_long %&gt;% sample_n(10) ## # A tibble: 10 x 4 ## CodeTourbiere ID nutrient concentration ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 BP 7 P_pourc 0.162 ## 2 2 16 P_pourc 0.167 ## 3 NTP 52 N_pourc 1.88 ## 4 NTP 51 P_pourc 0.104 ## 5 NTP 53 K_pourc 0.345 ## 6 1 79 N_pourc 2.12 ## 7 BS2 64 N_pourc 1.89 ## 8 1 84 P_pourc 0.161 ## 9 WTP 87 N_pourc 1.72 ## 10 1 75 N_pourc 2.55 L’opération inverse est pivot_wider(), avec laquelle nous sélectionnons une colonne spécifiant les nouvelles colonnes à construire (names_from) ainsi que les valeurs à placer dans ces colonnes (values_-_from). chicoute_large &lt;- chicoute_long %&gt;% pivot_wider(names_from = nutrient, values_from = concentration) chicoute_large %&gt;% sample_n(10) ## # A tibble: 10 x 5 ## CodeTourbiere ID N_pourc P_pourc K_pourc ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 15 2.90 0.166 1.01 ## 2 2 14 3.10 0.207 1.33 ## 3 BS2 65 1.68 0.0721 1.09 ## 4 2 11 2.91 0.138 1.19 ## 5 1 85 1.98 0.141 1.16 ## 6 NTP 54 1.67 0.0869 0.456 ## 7 BP 6 2.13 0.151 0.729 ## 8 1 78 2.31 0.156 0.833 ## 9 2 12 2.70 0.147 1.24 ## 10 BEAU 5 2.04 0.115 0.947 3.5.4 Combiner des tableaux Nous avons introduit plus haut la notion de base de données. Nous voudrions peut-être utiliser le code des tourbières pour inclure leur nom, le type d’essai mené à ces tourbières, etc. Importons d’abord le tableau des noms liés aux codes. tourbieres &lt;- read_csv2(&quot;data/chicoute_tourbieres.csv&quot;) ## Using &#39;,&#39; as decimal and &#39;.&#39; as grouping mark. Use read_delim() for more control. ## Parsed with column specification: ## cols( ## Tourbiere = col_character(), ## CodeTourbiere = col_character(), ## Type = col_character(), ## TypeCulture = col_character() ## ) tourbieres ## # A tibble: 11 x 4 ## Tourbiere CodeTourbiere Type TypeCulture ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Beaulieu BEAU calibration naturel ## 2 Brador Path BP calibration naturel ## 3 Lichen (BS2E) 2 validation cultive sec ## 4 Mannys Brook MB calibration naturel ## 5 Middle Bay Road MR calibration naturel ## 6 North Est of Smelt Pond NESP calibration naturel ## 7 North of Blue Moon NBM calibration naturel ## 8 South of Smelt Pond SSP calibration naturel ## 9 Sphaigne (BS2F) BS2 validation cultive sec ## 10 Sphaigne (BS2F) 1 calibration naturel ## 11 West of Trout Pond WTP calibration naturel Notre information est organisée en deux tableaux, liés par la colonne CodeTourbiere. Comment fusionner l’information pour qu’elle puisse être utilisée dans son ensemble? La fonction left_join effectue cette opération typique avec les bases de données. chicoute_merge &lt;- left_join(x = chicoute, y = tourbieres, by = &quot;CodeTourbiere&quot;) # ou bien chicoute %&gt;% left_join(y = tourbieres, by = &quot;CodeTourbiere&quot;) chicoute_merge %&gt;% sample_n(4) ## # A tibble: 4 x 34 ## ID CodeTourbiere Ordre Site Traitement DemiParcelle SousTraitement ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 60 SSP F 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 61 BS2 G 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 56 SSP F 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 19 2 8 15 fertilisa… left B ## # … with 27 more variables: Latitude_m &lt;dbl&gt;, Longitude_m &lt;dbl&gt;, ## # Rendement_g_5m2 &lt;dbl&gt;, TotalRamet_nombre_m2 &lt;dbl&gt;, ## # TotalVegetatif_nombre_m2 &lt;dbl&gt;, TotalFloral_nombre_m2 &lt;dbl&gt;, ## # TotalMale_nombre_m2 &lt;dbl&gt;, TotalFemelle_nombre_m2 &lt;dbl&gt;, ## # FemelleFruit_nombre_m2 &lt;dbl&gt;, FemelleAvorte_nombre_m2 &lt;dbl&gt;, ## # SterileFleur_nombre_m2 &lt;dbl&gt;, C_pourc &lt;dbl&gt;, N_pourc &lt;dbl&gt;, P_pourc &lt;dbl&gt;, ## # K_pourc &lt;dbl&gt;, Ca_pourc &lt;dbl&gt;, Mg_pourc &lt;dbl&gt;, S_pourc &lt;dbl&gt;, ## # B_pourc &lt;dbl&gt;, Cu_pourc &lt;dbl&gt;, Zn_pourc &lt;dbl&gt;, Mn_pourc &lt;dbl&gt;, ## # Fe_pourc &lt;dbl&gt;, Al_pourc &lt;dbl&gt;, Tourbiere &lt;chr&gt;, Type &lt;chr&gt;, ## # TypeCulture &lt;chr&gt; D’autres types de jointures sont possibles, et décrites en détails dans la documentation. Garrick Aden-Buie a préparé de jolies animations pour décrire les différents types de jointures. left_join(x, y) colle y à x seulement ce qui dans y correspond à ce que l’on trouve dans x. right_join(x, y) colle y à x seulement ce qui dans x correspond à ce que l’on trouve dans y. inner_join(x, y) colle x et y en excluant les lignes où au moins une variable de joint est absente dans x et y. full_join(x, y)garde toutes les lignes et les colonnes de x et y. 3.5.5 Opérations sur les tableaux Les tableaux peuvent être segmentés en éléments sur lesquels on calculera ce qui nous chante. On pourrait vouloir obtenir: la somme avec la function sum() la moyenne avec la function mean() ou la médiane avec la fonction median() l’écart-type avec la function sd() les maximum et minimum avec les fonctions min() et max() un décompte d’occurrence avec la fonction n() ou count() Par exemple, mean(chicoute$Rendement_g_5m2, na.rm = TRUE) ## [1] 13.32851 En mode classique, pour effectuer des opérations sur des tableaux, on utilisera la fonction apply(). Cette fonction prend, comme arguments, le tableau, l’axe (opération par ligne = 1, opération par colonne = 2), puis la fonction à appliquer. apply(chicoute %&gt;% select(contains(&quot;pourc&quot;)), 2, mean) ## C_pourc N_pourc P_pourc K_pourc Ca_pourc Mg_pourc ## 5.027911e+01 2.199411e+00 1.388959e-01 8.887000e-01 3.884391e-01 4.980142e-01 ## S_pourc B_pourc Cu_pourc Zn_pourc Mn_pourc Fe_pourc ## 1.347177e-01 3.090922e-03 4.089891e-04 6.662155e-03 3.345239e-02 1.514885e-02 ## Al_pourc ## 2.694979e-03 Les opération peuvent aussi être effectuées par ligne, par exemple une somme (je garde seulement les 10 premiers résultats). apply(chicoute %&gt;% select(contains(&quot;pourc&quot;)), 1, sum)[1:10] ## [1] 55.64299 55.76767 54.78856 55.84453 57.89671 55.53603 55.62526 55.10991 ## [9] 55.06295 55.16774 La fonction à appliquer peut être personnalisée, par exemple: apply(chicoute %&gt;% select(contains(&quot;pourc&quot;)), 2, function(x) (prod(x))^(1/length(x))) ## C_pourc N_pourc P_pourc K_pourc Ca_pourc Mg_pourc ## 50.253429104 2.165246915 0.133754530 0.846193827 0.376192724 0.491763884 ## S_pourc B_pourc Cu_pourc Zn_pourc Mn_pourc Fe_pourc ## 0.129900753 0.003014675 0.000000000 0.006408775 0.024140327 0.014351745 ## Al_pourc ## 0.002450982 Vous reconnaissez cette fonction? C’était la moyenne géométrique (la fonction prod() étant le produit d’un vecteur). En mode tidyverse, on aura besoin principalement des fonction suivantes: group_by() pour effectuer des opérations par groupe, l’opération group_by() sépare le tableau en plusieurs petits tableaux, en attendant de les recombiner. C’est un peu l’équivalent des facettes avec le module de visualisation ggplot2, que nous explorons au chapitre 4. summarise() pour réduire plusieurs valeurs en une seule, il applique un calcul sur le tableau ou s’il y a lieu sur chaque petit tableau segmenté. Il en existe quelques variantes. summarise_all() applique la fonction à toutes les colonnes summarise_at() applique la fonction aux colonnes spécifiées summarise_if() applique la fonction aux colonnes qui ressortent comme TRUE selon une opération booléenne mutate() pour ajouter une nouvelle colonne Si l’on désire ajouter une colonne à un tableau, par exemple le sommaire calculé avec summarise(). À l’inverse, la fonction transmute() retournera seulement le résultat, sans le tableau à partir duquel il a été calculé. De même que summarise(), mutate() et transmute() possèdent leurs équivalents _all(), _at() et _if(). arrange() pour réordonner le tableau On a déjà couvert arrange() dans le chapitre 3. Rappelons que cette fonction n’est pas une opération sur un tableau, mais plutôt un changement d’affichage en changeant l’ordre d’apparition des données. Ces opérations sont décrites dans l’aide-mémoire Data Transformation Cheat Sheet (figure 3.5)). Figure 3.5: Aide-mémoire pour la transformation des données, https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf Pour effectuer des statistiques par colonne, on utilisera summarise pour des statistiques effectuées sur une seule colonne. sumarise peut prendre le nombre désiré de statistiques dont la sortie est un scalaire. chicoute %&gt;% summarise(moyenne = mean(TotalFloral_nombre_m2, na.rm = TRUE), ecart_type = sd(TotalFloral_nombre_m2, na.rm = TRUE)) ## # A tibble: 1 x 2 ## moyenne ecart_type ## &lt;dbl&gt; &lt;dbl&gt; ## 1 52.1 40.4 Si l’on désire un sommaire sur toutes les variables sélectionnées, on utilisera summarise_all(). Pour spécifier que l’on désire la moyenne et l’écart-type on inscrit les noms des fonctions dans list(). chicoute %&gt;% select(contains(&quot;pourc&quot;)) %&gt;% summarise_all(list(mean, sd)) ## # A tibble: 1 x 26 ## C_pourc_fn1 N_pourc_fn1 P_pourc_fn1 K_pourc_fn1 Ca_pourc_fn1 Mg_pourc_fn1 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 50.3 2.20 0.139 0.889 0.388 0.498 ## # … with 20 more variables: S_pourc_fn1 &lt;dbl&gt;, B_pourc_fn1 &lt;dbl&gt;, ## # Cu_pourc_fn1 &lt;dbl&gt;, Zn_pourc_fn1 &lt;dbl&gt;, Mn_pourc_fn1 &lt;dbl&gt;, ## # Fe_pourc_fn1 &lt;dbl&gt;, Al_pourc_fn1 &lt;dbl&gt;, C_pourc_fn2 &lt;dbl&gt;, ## # N_pourc_fn2 &lt;dbl&gt;, P_pourc_fn2 &lt;dbl&gt;, K_pourc_fn2 &lt;dbl&gt;, ## # Ca_pourc_fn2 &lt;dbl&gt;, Mg_pourc_fn2 &lt;dbl&gt;, S_pourc_fn2 &lt;dbl&gt;, ## # B_pourc_fn2 &lt;dbl&gt;, Cu_pourc_fn2 &lt;dbl&gt;, Zn_pourc_fn2 &lt;dbl&gt;, ## # Mn_pourc_fn2 &lt;dbl&gt;, Fe_pourc_fn2 &lt;dbl&gt;, Al_pourc_fn2 &lt;dbl&gt; On utilisera group_by() pour segmenter le tableau, et ainsi obtenir des statistiques pour chaque groupe. chicoute %&gt;% group_by(CodeTourbiere) %&gt;% summarise(moyenne = mean(TotalFloral_nombre_m2, na.rm = TRUE), ecart_type = sd(TotalFloral_nombre_m2, na.rm = TRUE)) ## # A tibble: 12 x 3 ## CodeTourbiere moyenne ecart_type ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 72.1 32.7 ## 2 2 37.1 32.9 ## 3 BEAU 149. 53.2 ## 4 BP 60.4 30.6 ## 5 BS2 27.2 15.5 ## 6 MB 64.7 40.8 ## 7 MR 35.1 10.5 ## 8 NBM 35.1 16.6 ## 9 NESP 21.4 4.88 ## 10 NTP 47.6 15.9 ## 11 SSP 25.7 11.1 ## 12 WTP 50.2 28.3 Dans le cas de summarise_all, les résultats s’affichent de la même manière. chicoute %&gt;% group_by(CodeTourbiere) %&gt;% select(N_pourc, P_pourc, K_pourc) %&gt;% summarise_all(list(mean, sd)) ## Adding missing grouping variables: `CodeTourbiere` ## # A tibble: 12 x 7 ## CodeTourbiere N_pourc_fn1 P_pourc_fn1 K_pourc_fn1 N_pourc_fn2 P_pourc_fn2 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2.26 0.156 0.880 0.250 0.0193 ## 2 2 2.76 0.181 1.12 0.178 0.0283 ## 3 BEAU 2.00 0.0967 1.12 0.179 0.0172 ## 4 BP 2.05 0.158 0.747 0.161 0.00625 ## 5 BS2 2.08 0.103 1.12 0.420 0.0218 ## 6 MB 2.15 0.109 0.675 0.114 0.0165 ## 7 MR 1.99 0.127 0.830 0.0802 0.0131 ## 8 NBM 2.01 0.127 0.854 0.310 0.0202 ## 9 NESP 1.76 0.135 0.945 0.149 0.0108 ## 10 NTP 1.83 0.0873 0.402 0.166 0.0103 ## 11 SSP 1.83 0.130 0.700 0.160 0.00383 ## 12 WTP 1.79 0.0811 0.578 0.132 0.00587 ## # … with 1 more variable: K_pourc_fn2 &lt;dbl&gt; Pour obtenir des statistiques à chaque ligne, mieux vaut utiliser apply(), tel que vu précédemment. Le point, ., représente le tableau dans une fonction qui n’a pas été conçu pour fonctionne de facto avec dplyr. chicoute %&gt;% select(contains(&quot;pourc&quot;)) %&gt;% apply(., 1, sum) ## [1] 55.64299 55.76767 54.78856 55.84453 57.89671 55.53603 55.62526 55.10991 ## [9] 55.06295 55.16774 56.41123 55.47917 55.43537 55.79175 55.44561 54.85448 ## [17] 54.34262 55.03075 54.40533 51.89319 54.70172 54.62176 54.30250 53.86976 ## [25] 53.44731 53.86244 52.43280 54.34978 53.96756 51.46672 55.44267 54.70350 ## [33] 55.30711 56.16200 56.64710 55.95499 54.76370 54.32775 54.95419 53.37094 ## [41] 53.07855 53.04541 52.09520 52.40456 51.92376 53.33248 56.56405 56.35004 ## [49] 56.27185 55.56986 53.81654 55.39638 55.51961 54.88098 54.74774 51.08921 ## [57] 51.31462 53.46819 53.15640 52.82020 57.78038 57.94636 56.65558 56.28845 ## [65] 55.54463 56.51751 55.36497 56.00594 55.64247 56.56967 56.81674 55.87070 ## [73] 55.72308 56.14116 56.42611 55.35650 54.90469 54.03674 53.42991 53.99334 ## [81] 53.09085 53.23222 53.28212 53.63192 53.48102 52.31131 51.72026 51.10534 ## [89] 51.49055 51.59297 Prenons ce tableau des espèces menacées issu de l’Union internationale pour la conservation de la nature distribuées par l’OCDE. library(&quot;tidyverse&quot;) especes_menacees &lt;- read_csv(&#39;data/WILD_LIFE_14012020030114795.csv&#39;) ## Parsed with column specification: ## cols( ## IUCN = col_character(), ## `IUCN Category` = col_character(), ## SPEC = col_character(), ## Species = col_character(), ## COU = col_character(), ## Country = col_character(), ## `Unit Code` = col_character(), ## Unit = col_character(), ## `PowerCode Code` = col_double(), ## PowerCode = col_character(), ## `Reference Period Code` = col_logical(), ## `Reference Period` = col_logical(), ## Value = col_double(), ## `Flag Codes` = col_logical(), ## Flags = col_logical() ## ) Nous exécutons le pipeline suivant. especes_menacees %&gt;% dplyr::filter(IUCN == &#39;CRITICAL&#39;, SPEC == &quot;VASCULAR_PLANT&quot;) %&gt;% dplyr::select(Country, Value) %&gt;% dplyr::group_by(Country) %&gt;% dplyr::summarise(n_critical_plants = sum(Value)) %&gt;% dplyr::arrange(desc(n_critical_plants)) %&gt;% dplyr::top_n(10) ## Selecting by n_critical_plants ## # A tibble: 10 x 2 ## Country n_critical_plants ## &lt;chr&gt; &lt;dbl&gt; ## 1 United States 1222 ## 2 Japan 525 ## 3 Canada 315 ## 4 Czech Republic 284 ## 5 Spain 271 ## 6 Belgium 253 ## 7 Austria 172 ## 8 Slovak Republic 155 ## 9 Australia 148 ## 10 Italy 128 Ce pipeline consiste à: prendre le tableau especes_menacees, puis filtrer pour n&#39;obtenir que les espèces critiques dans la catégorie des plantes vascularies, puis sélectionner les colonnes des pays et des valeurs (nombre d&#39;espèces), puis segmenter le tableaux en plusieurs tableaux selon le pays, puis appliquer la fonction sum pour chacun de ces petits tableaux (puis de recombiner ces sommaires), puis trier les pays en nombre décroissant de décompte d&#39;espèces, puis afficher le top 10 3.5.6 Exemple (difficile) Pour revenir à notre tableau chicoute, imaginez que vous aviez une station météo (station_A) située aux coordonnées (490640, 5702453) et que vous désiriez calculer la distance entre l’observation et la station. Prenez du temps pour réfléchir à la manière dont vous procéderez… On pourra créer une fonction qui mesure la distance entre un point x, y et les coordonnées de la station A… dist_station_A &lt;- function (x, y) { return(sqrt((x - 490640)^2 + (y - 5702453)^2)) } … puis ajouter une colonne avec mutate grâce à une fonction prenant les arguments x et y spécifiés. chicoute %&gt;% mutate(dist = dist_station_A(x = Longitude_m, y= Latitude_m)) %&gt;% select(ID, CodeTourbiere, Longitude_m, Latitude_m, dist) %&gt;% top_n(10) ## Selecting by dist ## # A tibble: 10 x 5 ## ID CodeTourbiere Longitude_m Latitude_m dist ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7 BP 484054 5706307 7631. ## 2 36 MR 459875 5701988 30769. ## 3 37 MR 459873 5701987 30771. ## 4 38 MR 459880 5701971 30764. ## 5 39 MR 459894 5701966 30750. ## 6 40 MR 459915 5701994 30728. ## 7 46 NBM 485975 5695688 8218. ## 8 48 NBM 485912 5696607 7519. ## 9 49 NBM 485903 5696611 7521. ## 10 50 NBM 485884 5696612 7532. Nous pourrions procéder de la même manière pour fusionner des données climatiques. Le tableau chicoute ne possède pas d’indicateurs climatiques, mais il est possible de les soutirer de stations météo placées près des site. Ces données ne sont pas disponibles pour le tableau de la chicouté, alors j’utiliserai des données fictives pour l’exemple. Voici ce qui pourrait être fait. Créer un tableau des stations météo ainsi que des indices météo associés à ces stations. Lier chaque site à une station (à la main où selon la plus petite distance entre le site et la station). Fusionner les indices climatiques aux sites, puis les sites aux mesures de rendement. Ces opérations demandent habituellement du tâtonnement. Il serait surprenant que même une personne expérimentée soit en mesure de compiler ces opérations sans obtenir de message d’erreur, et retravailler jusqu’à obtenir le résultat souhaité. L’objectif de cette section est de vous présenté un flux de travail que vous pourriez être amenés à effectuer et de fournir quelques éléments nouveau pour mener à bien une opération. Il peut être frustrant de ne pas saisir toutes les opérations: passez à travers cette section sans jugement. Si vous devez vous frotter à problème semblable, vous saurez que vous trouverez dans ce manuel une recette intéressante. mes_stations &lt;- data.frame(Station = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), Longitude_m = c(490640, 484870, 485929), Latitude_m = c(5702453, 5701870, 5696421), t_moy_C = c(13.8, 18.2, 16.30), prec_tot_mm = c(687, 714, 732)) mes_stations ## Station Longitude_m Latitude_m t_moy_C prec_tot_mm ## 1 A 490640 5702453 13.8 687 ## 2 B 484870 5701870 18.2 714 ## 3 C 485929 5696421 16.3 732 La fonction suivante calcule la distance entre des coordonnées x et y et chaque station d’un tableau de stations, puis retourne le nom de la station dont la distance est la moindre. dist_station &lt;- function (x, y, stations_df) { # stations est le tableau des stations à trois colonnes # 1iere: nom de la station # 2ieme: longitude # 3ieme: latitude distance &lt;- c() for (i in 1:nrow(stations_df)) { distance[i] &lt;- sqrt((x - stations_df[i, 2])^2 + (y - stations_df[i, 3])^2) } nom_station &lt;- as.character(stations_df$Station[which.min(distance)]) return(nom_station) } Testons la fonction avec des coordonnées. dist_station(x = 459875, y = 5701988, stations_df = mes_stations) ## [1] &quot;B&quot; Nous appliquons cette fonction à toutes les lignes du tableau, puis en retournons un échantillon. chicoute %&gt;% rowwise() %&gt;% mutate(Station = dist_station(x = Longitude_m, y = Latitude_m, stations_df = mes_stations)) %&gt;% select(ID, CodeTourbiere, Longitude_m, Latitude_m, Station) %&gt;% sample_n(10) ## Source: local data frame [10 x 5] ## Groups: &lt;by row&gt; ## ## # A tibble: 10 x 5 ## ID CodeTourbiere Longitude_m Latitude_m Station ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 25 2 486315 5702540 B ## 2 9 BP 484761 5706324 B ## 3 45 NESP 484875 5701861 B ## 4 20 2 486517 5702537 B ## 5 82 1 486505 5702162 B ## 6 84 1 486514 5702160 B ## 7 24 2 486327 5702544 B ## 8 6 BP 484865 5706394 B ## 9 59 SSP 484454 5699796 B ## 10 75 1 486458 5702106 B Cela semble fonctionner. On peut y ajouter un left_join() pour joindre les données météo au tableau principal. chicoute_weather &lt;- chicoute %&gt;% rowwise() %&gt;% mutate(Station = dist_station(x = Longitude_m, y = Latitude_m, stations_df = mes_stations)) %&gt;% left_join(y = mes_stations, by = &quot;Station&quot;) ## Warning: Column `Station` joining character vector and factor, coercing into ## character vector chicoute_weather %&gt;% sample_n(10) ## Source: local data frame [10 x 36] ## Groups: &lt;by row&gt; ## ## # A tibble: 10 x 36 ## ID CodeTourbiere Ordre Site Traitement DemiParcelle SousTraitement ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 71 1 2 3 fertilisa… right Cu ## 2 88 WTP E 3 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 36 MR I 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 59 SSP F 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 39 MR I 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 6 37 MR I 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 7 9 BP H 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 8 64 BS2 G 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 9 24 2 9 17 fertilisa… right Cu ## 10 34 MB C 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # … with 29 more variables: Latitude_m.x &lt;dbl&gt;, Longitude_m.x &lt;dbl&gt;, ## # Rendement_g_5m2 &lt;dbl&gt;, TotalRamet_nombre_m2 &lt;dbl&gt;, ## # TotalVegetatif_nombre_m2 &lt;dbl&gt;, TotalFloral_nombre_m2 &lt;dbl&gt;, ## # TotalMale_nombre_m2 &lt;dbl&gt;, TotalFemelle_nombre_m2 &lt;dbl&gt;, ## # FemelleFruit_nombre_m2 &lt;dbl&gt;, FemelleAvorte_nombre_m2 &lt;dbl&gt;, ## # SterileFleur_nombre_m2 &lt;dbl&gt;, C_pourc &lt;dbl&gt;, N_pourc &lt;dbl&gt;, P_pourc &lt;dbl&gt;, ## # K_pourc &lt;dbl&gt;, Ca_pourc &lt;dbl&gt;, Mg_pourc &lt;dbl&gt;, S_pourc &lt;dbl&gt;, ## # B_pourc &lt;dbl&gt;, Cu_pourc &lt;dbl&gt;, Zn_pourc &lt;dbl&gt;, Mn_pourc &lt;dbl&gt;, ## # Fe_pourc &lt;dbl&gt;, Al_pourc &lt;dbl&gt;, Station &lt;chr&gt;, Longitude_m.y &lt;dbl&gt;, ## # Latitude_m.y &lt;dbl&gt;, t_moy_C &lt;dbl&gt;, prec_tot_mm &lt;dbl&gt; 3.5.7 Exporter un tableau Simplement avec write_csv(). write_csv(chicoute_weather, &quot;data/chicoute_weather.csv&quot;) 3.5.8 Aller plus loin dans le tidyverse Le livre R for Data Science, de Hadley Wickham et Garrett Grolemund (couverture à la figure 3.6), est un incontournable. Figure 3.6: Couverture du libre de Hadley Wickham et Garrett Grolemund, Source: https://r4ds.had.co.nz 3.6 Références Parent L.E., Parent, S.É., Herbert-Gentile, V., Naess, K. et Lapointe, L. 2013. Mineral Balance Plasticity of Cloudberry (Rubus chamaemorus) in Quebec-Labrador Bogs. American Journal of Plant Sciences, 4, 1508-1520. DOI: 10.4236/ajps.2013.47183 "]
]
