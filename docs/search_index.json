[
["chapitre-ode.html", "14 ModÃ©lisation dÃ©terministe 14.1 Ã‰quations diffÃ©rentielles 14.2 Les Ã©quations diffÃ©rentielles ordinaires en modÃ©lisation Ã©cologique 14.3 Les Ã©quations diffÃ©rentielles partielles en modÃ©lisation Ã©cologique", " 14 ModÃ©lisation dÃ©terministe ï¸ Objectifs spÃ©cifiques: Ã€ la fin de ce chapitre, vous saurez dÃ©finir une Ã©quation diffÃ©rentielle ordinaire et une Ã©quation diffÃ©rentielle partielle saurez aptes Ã  dÃ©tecter un problÃ¨me impliquant le besoin dâ€™utiliser des Ã©quations diffÃ©rentielles serez en mesure dâ€™effectuer une modÃ©lisation impliquant un systÃ¨me dâ€™EDO en contexte Ã©cologique De plus, en extra (non Ã©valuÃ©, objectif incertain), vous - serez en mesure dâ€™effectuer une modÃ©lisation par diffÃ©rences finies impliquant une EDP simple en contexte Ã©cologique On se rÃ©fÃ¨re Ã  la modÃ©lisation mÃ©canistique lorsque des principes thÃ©oriques guident une modÃ©lisation, Ã  lâ€™inverse de la modÃ©lisation phÃ©nomÃ©nologique, qui est guidÃ©e par les donnÃ©es. Il existe de nombreuses techniques de modÃ©lisation mÃ©canistique, mais la plupart sont guidÃ©es par les Ã©quations diffÃ©rentielles. 14.1 Ã‰quations diffÃ©rentielles Les Ã©quations diffÃ©rentielles permettent la rÃ©solution de problÃ¨mes impliquant des gradients dans le temps et dans lâ€™espace. On les utilise pour modÃ©liser la dynamique des populations, la thermodynamique, lâ€™Ã©coulement de lâ€™eau dans les sols, le transport des solutÃ©s, etc. On en distingue deux grandes catÃ©gories: les Ã©quations diffÃ©rentielles ordinaires et partielles. Ã‰quations diffÃ©rentielles ordinaires (EDO). Les Ã©quations diffÃ©rentielles ordinaires sâ€™appliquent sur des fonctions sâ€™appliquant Ã  une seule variables, qui est souvent le temps. On pourra suivre, par exemple, lâ€™Ã©volution de la tempÃ©rature en un point, en fonction du temps Ã  partir dâ€™une condition initiale. Parfois, plusieurs EDO sont utilisÃ©es conjointement pour crÃ©er un systÃ¨me dâ€™EDO que lâ€™on pourra nommÃ© un systÃ¨me dynamique. Les solutions analytiques des EDO sont parfois relativement faciles Ã  rÃ©soudre, mais les ordinateurs permettent des rÃ©solutions numÃ©riques en quelques lignes de code. Ã‰quations diffÃ©rentielles partielles (EDP). Dans ce cas, ce sont plusieurs variables qui sont diffÃ©renciÃ©es dans la mÃªme fonction. Il peut sâ€™agir des coordonnÃ©es dans lâ€™espace \\([x, y, z]\\) (rÃ©gime permanent), qui peuvent aussi Ãªtre appliquÃ©s Ã  diffÃ©rents pas de temps (rÃ©gime transitoire). Le problÃ¨me sera dÃ©limitÃ© non pas seulement par des conditions initiales, mais aussi par des conditions aux frontiÃ¨res du modÃ¨le. Puisque que les solutions analytiques des EDP peuvent rarement Ãªtre dÃ©veloppÃ©es, on utilisera pratiquement toujours des approches numÃ©riques que sont principalement les mÃ©thodes de rÃ©solution par diffÃ©rences finies ou par Ã©lÃ©ments finis. 14.2 Les Ã©quations diffÃ©rentielles ordinaires en modÃ©lisation Ã©cologique Lâ€™Ã©volution des populations dans le temps peut Ãªtre abordÃ©e Ã  lâ€™aide de systÃ¨mes dâ€™Ã©quations diffÃ©rentielles. Une simple Ã©quation dÃ©crivant la croissance dâ€™une population peut Ãªtre couplÃ©e Ã  des schÃ©mas dâ€™exploitation de cette population, que ce soit une exploitation forestiÃ¨re, une terre fourragÃ¨re ou un territoire de chasse. On pourra aussi faire interagir des populations dans des schÃ©mas de relations biologiques. Ces processus peuvent Ãªtre implÃ©mentÃ©s avec des processus alÃ©atoires pour gÃ©nÃ©rer des schÃ©mas probabilistes. De plus, les biostatistiques et lâ€™autoapprentissage peuvent Ãªtre mis Ã  contribution afin de calibrer les modÃ¨les. 14.2.1 Ã‰volution dâ€™une seule population en fonction du temps La croissance dâ€™une population (ou de sa densitÃ©) isolÃ©e en fonction du temps dÃ©pend des conditions qui lui offre son environnement. Dans le cas de la biomasse dâ€™une culture Ã  croissance constante, le taux de croissance est toujours le mÃªme. \\[ \\frac{d ğŸŒ¿ }{dt} = c \\] \\[ \\int_0^t c dt = \\int_{ğŸŒ¿_0}^{ğŸŒ¿(t)} ~dğŸŒ¿ \\] \\[ ct = ğŸŒ¿(t) - ğŸŒ¿_0\\] \\[ ğŸŒ¿(t) = ğŸŒ¿_0 + ct \\] par(mar=c(4, 4, 1, 1), ps=10) y0 &lt;- 2 c &lt;- 2 # exprimÃ© en individu / pas de temps times &lt;- seq(0, 6, 0.1) y &lt;- y0 + c * times plot(times, y, &#39;l&#39;, xlab=&quot;An&quot;, ylab=&quot;Population&quot;, ylim=c(0, max(y))) text(max(times), max(y), round(max(y))) Dans le cas dâ€™une population qui se reproduit, une formulation simple modÃ©lise une Ã©volution linÃ©aire associÃ©e Ã  un taux de natalitÃ© \\(n\\) et un taux de mortalitÃ© \\(m\\), oÃ¹ \\(r = n-m\\) est le taux de croissance de la population dâ€™une population de lapins ğŸ° en fonction du temps \\(t\\). \\[ \\frac{dğŸ°}{dt} = nğŸ° - mğŸ° = rğŸ° \\] \\[ \\int_0^t dt = \\int_{ğŸ°_0}^{ğŸ°(t)} \\frac{1}{rğŸ°} ~dğŸ° \\] \\[ t = \\frac{1}{r} ln(ğŸ°) \\bigg\\rvert_{ğŸ°_0}^{ğŸ°(t)} \\] \\[ rt = ln \\left( \\frac{ğŸ°(t)}{ğŸ°_0} \\right) \\] \\[ ğŸ°(t) = ğŸ°_0 exp(rt) \\] La vitesse de croissance est constante pour une population constante, mais la croissance de la population est exponentielle Ã©tant donnÃ©e que chaque nouvel individu se reproduit. par(mar=c(4, 4, 1, 1), ps=10) y0 &lt;- 10 r &lt;- 0.2 # exprimÃ© en individu / pas de temps times &lt;- seq(0, 10, 0.1) y &lt;- y0 * exp(r*times) plot(times, y, &#39;l&#39;, xlab=&quot;An&quot;, ylab=&quot;Lapin&quot;, ylim=c(0, max(y))) text(max(times), max(y), round(max(y))) De 10 lapins au dÃ©part, nous en avons un peu plus de 75 aprÃ¨s 10 ansâ€¦ et prÃ¨s de 5 milliards aprÃ¨s 100 ans! En fait, la capacitÃ© de support dâ€™une population Ã©tant gÃ©nÃ©ralement limitÃ©e, on peut supposer que le taux de natalitÃ© dÃ©croit et que le taux de mortalitÃ© croit linÃ©airement avec lâ€™effectif. \\[ n(ğŸ°) = \\alpha - \\beta ğŸ° \\] \\[ m(ğŸ°) = \\gamma + \\delta ğŸ° \\] On aura donc \\[ \\frac{dğŸ°}{dt} = ğŸ° \\left( \\alpha - \\beta ğŸ° \\right) - ğŸ° \\left( \\gamma + \\delta ğŸ° \\right) = rğŸ° \\left( 1 - \\frac{ğŸ°}{K} \\right) \\] oÃ¹ \\(r = \\alpha - \\gamma\\) est lâ€™ordonnÃ©e Ã  lâ€™origine du taux de croissance (thÃ©orique, lorsque la population est nulle) et \\(K = \\frac{\\alpha-\\gamma}{\\beta + \\delta}\\) est la capacitÃ© limite du milieu de subsistance. On pourra sâ€™aider dâ€™un logiciel de calcul symbolique comme sympy ou maxima pour en tirer une solution analytique. Mais Ã  ce point, nous utiliserons une approximation numÃ©rique. Nous utiliserons le module deSolve. library(&quot;deSolve&quot;) deSolve demande de dÃ©finir les paramÃ¨tres de lâ€™EDO ou du systÃ¨me dâ€™EDO. Nous devons dâ€™abord spÃ©cifier Ã  quels pas de temps notre EDO doit Ãªtre approximÃ©e. Jâ€™Ã©tends la plage de temps Ã  30 ans pour bien visualiser la courbe de croissance. times &lt;- seq(0, 30, by = 0.5) Les conditions initiales du systÃ¨me dâ€™EDO sont aussi dÃ©finies dans un vecteur. La seule condition initiale de notre EDO est le nombre initial de lapin. y0 &lt;- c(lapin = 10) On dÃ©finira les paramÃ¨tres dans un vecteur p. Dans notre cas, nous avons \\(r\\), le taux de croissance Ã  lâ€™origine et \\(K\\), la capacitÃ© de support de lâ€™Ã©cosystÃ¨me. Il est prÃ©fÃ©rable de nommer les paramÃ¨tres du vecteur pour Ã©viter les erreurs. p &lt;- c(r = 0.2, K = 40) Enfin, une fonction dÃ©finit lâ€™EDO avec, comme entrÃ©es, les pas de temps, les conditions initiales et les paramÃ¨tres. La sortie de la fonction est un vecteur des dÃ©rivÃ©es emboÃ®tÃ©s dans une liste (lisez le fichier dâ€™aide de la fonction ode pour les dÃ©tails en lanÃ§ant ?ode). model_logistic &lt;- function(t, y, p) { lapin &lt;- y[1] dlapin_dt &lt;- p[1] * lapin * (1 - lapin/p[2]) return(list(c(dlapin_dt))) } Une fois que les pas de temps, les conditions initiales, les paramÃ¨tres et le modÃ¨le sont dÃ©finis, on les spÃ©cifie comme arguments dans la fonction ode. La sortie de la fonction ode est une matrice dont la premiÃ¨re colonne comprend les pas de temps imposÃ©s, et les autres colonnes sont les dÃ©rivÃ©es spÃ©cifiÃ©es Ã  la sortie de la fonction ode. lapin_t &lt;- ode(y = y0, times = times, model_logistic, p) head(lapin_t) ## time lapin ## [1,] 0.0 10.00000 ## [2,] 0.5 10.76856 ## [3,] 1.0 11.57342 ## [4,] 1.5 12.41288 ## [5,] 2.0 13.28478 ## [6,] 2.5 14.18643 par(mar=c(4, 4, 1, 1), ps=10) plot(lapin_t[, 1], lapin_t[, 2], type=&#39;l&#39;, xlab=&quot;An&quot;, ylab=&quot;Lapin&quot;, ylim=c(0, max(lapin_t[, 2]))) Exercice. Que ce passerait-il si le taux de croissance Ã©tait nÃ©gatif? Profitez-en pour changer les paramÃ¨tres r et K. Exercice. Dâ€™autres formulations existent pour exprimer des taux de croissance (Gompertz, Allee, etc.). En outre la formulation de Gompertz sâ€™Ã©crit comme suit. \\[ \\frac{dğŸ°}{dt} = rğŸ° \\left( ln \\frac{K}{ğŸ°} \\right) \\] Entrer cet EDO dans R avec deSolve. 14.2.2 Population exploitÃ©e Lâ€™exploitation dâ€™une population peut Ãªtre effectuÃ©e de diffÃ©rentes maniÃ¨res. Dâ€™abord, le prÃ©lÃ¨vement peut Ãªtre effectuÃ© de maniÃ¨re constante, par exemple dans un Ã©levage ou par la chasse ou la cueillette. Ajoutons un prÃ©lÃ¨vement constant dans une courbe de croissance logistique. \\[ \\frac{dğŸ°}{dt} = rğŸ° \\left( 1 - \\frac{ğŸ°}{K} \\right) - Q \\] oÃ¹ \\(Q\\) est le quota, ou le prÃ©lÃ¨vement constant. On pourra aussi effectuer un prÃ©lÃ¨vement proportionnel Ã  la population. \\[ \\frac{dğŸ°}{dt} = rğŸ° \\left( 1 - \\frac{ğŸ°}{K} \\right) - EğŸ° \\] oÃ¹ \\(E\\) est lâ€™effort dâ€™exploitation. Ou bien effectuer une sÃ©rie de prÃ©lÃ¨vement ponctuels, comme la rÃ©colte de plantes fourragÃ¨res. \\[ \\frac{dğŸŒ¿}{dt} = c - \\left[ ğŸŒ¿ - \\gamma \\right] \\bigg\\rvert_{t=a, b, c, d, e, ...} \\] oÃ¹ \\(\\gamma\\) est le reste de la biomasse aprÃ¨s la rÃ©colte et \\(t=a, b, c, d, e, ...\\) sont les pas de temps oÃ¹ le bloc entre les crochets est actif, câ€™est-Ã -dire la pÃ©riode de rÃ©colte. La solution analytique dâ€™une culture Ã  croissance constante est plutÃ´t facile Ã  dÃ©duire. Les fonctions de prÃ©lÃ¨vement peuvent Ãªtre modulÃ©es Ã  votre guise. Prenons pour lâ€™exemple un prÃ©lÃ¨vement constant et une croissance logistique. p &lt;- c(r = 0.2, K = 40, Q = 1) model_logistic_expl &lt;- function(t, y, p) { lapin &lt;- y[1] dlapin_dt &lt;- p[1] * lapin * (1 - lapin/p[2]) - p[3] return(list(c(dlapin_dt))) } lapin_t &lt;- ode(y = y0, times = times, model_logistic_expl, p) par(mar=c(4, 4, 1, 1), ps=10) plot(lapin_t[, 1], lapin_t[, 2], type=&#39;l&#39;, xlab=&quot;An&quot;, ylab=&quot;Lapin&quot;, ylim=c(0, max(lapin_t[, 2]))) Exercice. ModÃ©liser avec un prÃ©lÃ¨vement proportionnel. Lâ€™exploitation ponctuelle, comme la rÃ©colte ou lâ€™administration dâ€™une sÃ©rie de traitements, implique lâ€™utilisation dâ€™approches intermittentes. deSolve ignore les changements dans les variables dâ€™Ã©tat (y) tels que dÃ©finis dans les dÃ©rivÃ©s. Pour ce faire, nous devons avoir recours Ã  des Ã©vÃ¨nements dans le jargon de deSolve. Ces Ã©vÃ¨nements doivent Ãªtre spÃ©cifiÃ©s dans un data.frame ou une liste. Il est difficile de trouver un exemple gÃ©nÃ©rique pour modÃ©liser des Ã©vÃ¨nements. Pour en savoir davantage, je vous invite donc Ã  consulter la fiche dâ€™aide ?events. Dans notre cas, nous allons modÃ©liser une rÃ©colte de plantes fourragÃ¨res. La rÃ©colte est dÃ©clenchÃ©e lorsque le rendement atteint 2 t/ha, et laisser 0.3 t/ha au sol pour assurer le renouvellement pour les coupes subsÃ©quentes. DÃ©finissons dâ€™abord les entrÃ©es du modÃ¨les. times &lt;- seq(0, 120, 0.1) p &lt;- c(r = 0.1, K = 2.5) y0 &lt;- c(champ = 0.1) Nous devons dÃ©finir une fonction root, dont la sortie est une valeur qui dÃ©clenchera un Ã©vÃ¨nement lorsque la valeur sera nulle. Dans notre cas, la valeur correspond simplement au rendement moins 2, la quantitÃ© au champ y[1]. Notez que dâ€™autres stratÃ©gies peuvent Ãªtre utilisÃ©es pour dÃ©clencher une rÃ©colte, par exemple le pourcentage de floraison qui demanderait des simulations plus poussÃ©es. recolte_root &lt;- function(t, y, p) y[1]-2 Puis, lorsque la fonction root est dÃ©clenchÃ©e, lâ€™Ã©vÃ¨nement ramÃ¨ne la quantitÃ© au champs Ã  1 t/ha, une quantitÃ© qui permet de relancer la croissance. recolte_event &lt;- function(t, y, p) { y[1] &lt;- 0.3 return(y) } La fonction du modÃ¨le est telle quâ€™utilisÃ©e auparavant: une fonction logistique. recolte &lt;- function(t, y, p) { champ &lt;- y[1] dchamp_dt &lt;- p[1] * champ * (1 - champ/p[2]) return(list(c(dchamp_dt))) } La fonction ode est lancÃ©e en entrant les fonction root et events. out &lt;- ode(times = times, y = y0, func = recolte, parms = p, rootfun = recolte_root, events = list(func = recolte_event, root = TRUE), method=&quot;impAdams&quot;) plot(out) Nous pourrons organiser deux rÃ©coltes de 1.7 t/ha et une de 2 t/ha pour terminer la saison. Exercice. Quâ€™adviendrait-il si vous laissiez 0.15 t/ha au champ au lieu de 0.3? Ou si vous laissiez 1 t/ha? Ou si vous dÃ©clenchiez une rÃ©colte Ã  2.3 t/ha? DÃ©fi. Pouvez-vous modÃ©liser lâ€™ensilage? 14.2.3 Interactions biologiques Les interactions biologiques entre deux espÃ¨ces Ã  un stade de croissance dÃ©fini peuvent prendre diffÃ©rentes formes, du mutualisme (les deux espÃ¨ces bÃ©nÃ©ficient de la relation) Ã  la compÃ©tition (les deux espÃ¨ces se nuisent) en passant par la prÃ©dation ou le parasitisme (une espÃ¨ce bÃ©nÃ©ficie de lâ€™autre en lui nuisant) ou le neutralisme (aucun effet). Ces effets sont dÃ©crits dans Pringle (2016) en un tableau synthÃ¨se. Source: Pringle, E.G. 2016. Orienting the Interaction Compass: Resource Availability as a Major Driver of Context Dependence. Plos Biology. https://doi.org/10.1371/journal.pbio.2000891 Ces interactions peuvent Ãªtre dÃ©crite mathÃ©matiquement dans des systÃ¨mes dâ€™EDO, ou EDO couplÃ©es. Le cas dâ€™Ã©tude le plus courant reprend le systÃ¨me dâ€™Ã©quation prÃ©dateur-proie de Lotka-Volterra, deux auteurs ayant dÃ©veloppÃ© de maniÃ¨re indÃ©pendante des Ã©quations similaires respectivement en 1925 et 1926. Les Ã©quations de Lotka-Volterra supposent une croissance illimitÃ©e des deux espÃ¨ces: les proies ğŸ° se reproduisent par elles-mÃªmes (\\(\\alpha ğŸ°\\)), tandis que les prÃ©dateurs ğŸ¦Š croissent selon la disponibilitÃ© des proies (\\(\\delta ğŸ°ğŸ¦Š\\)). Ã€ lâ€™inverse, la mortalitÃ© des proies dÃ©pend du nombre de prÃ©dateurs (\\(- \\beta ğŸ°ğŸ¦Š\\)), mais la mortalitÃ© des prÃ©dateurs est indÃ©pendante des proies (\\(- \\gamma ğŸ¦Š\\)). On obtient ainsi un systÃ¨me dâ€™Ã©quation. \\[\\frac{dğŸ°}{dt} = \\alpha ğŸ° - \\beta ğŸ°ğŸ¦Š = ğŸ° \\left( \\alpha - \\beta ğŸ¦Š \\right)\\] \\[\\frac{dğŸ¦Š}{dt} = \\delta ğŸ°ğŸ¦Š - \\gamma ğŸ¦Š = ğŸ¦Š \\left( \\delta ğŸ° - \\gamma \\right) \\] Ã€ lâ€™Ã©quilibre de ğŸ°, câ€™est-Ã -dire oÃ¹ \\(\\frac{dğŸ°}{dt} = 0\\), on retrouve \\(ğŸ°=0\\) ou \\(ğŸ¦Š = \\frac{\\alpha}{\\beta}\\). De mÃªme, Ã  lâ€™Ã©quilibre de ğŸ¦Š, on retrouve \\(ğŸ¦Š=0\\) ou \\(ğŸ° = \\frac{\\gamma}{\\delta}\\). En termes mathÃ©matiques, ces Ã©quilibre sont des isoclines, des points dâ€™inflexion dans le systÃ¨me dâ€™EDO. Nous allons rÃ©soudre les Ã©quations de Lotka-Volterra avec deSolve. Rappelons-nous que nous devons dÃ©finir des pas de temps oÃ¹ approximer les populations (times), des conditions initiales (y0) et des paramÃ¨tres (p). times &lt;- seq(0, 30, by = 0.1) y0 &lt;- c(lapin = 3, renard = 1) p &lt;- c(alpha = 2, # taux de croissance des lapins (naissance - mortalitÃ©, 1/an) beta = 0.8, # taux de prÃ©dation des lapins (renard / an) delta = 0.1, # taux de conversion lors de la prÃ©dation (lapin / renard) gamma = 0.2) # mortalitÃ© naturelle des renards (1/an) On peut calculer dâ€™emblÃ©e les isoclines. lapin_iso &lt;- p[4]/p[3] renard_iso &lt;- p[1]/p[2] Nous devons ensuite crÃ©er notre modÃ¨le. modele_LV &lt;- function(t, y, p) { lapin = y[1] renard = y[2] dlapin_dt = p[1] * lapin - p[2] * lapin * renard drenard_dt = p[3] * lapin * renard - p[4] * renard return(list(c(dlapin_dt, drenard_dt))) } LanÃ§ons lâ€™approximation. effectifs_t = ode(y = y0, times = times, modele_LV, p) head(effectifs_t) ## time lapin renard ## [1,] 0.0 3.000000 1.000000 ## [2,] 0.1 3.380961 1.011940 ## [3,] 0.2 3.806028 1.028156 ## [4,] 0.3 4.278154 1.049326 ## [5,] 0.4 4.799633 1.076263 ## [6,] 0.5 5.371673 1.109943 par(mar=c(4, 4, 1, 1), ps=10) plot(effectifs_t[, 1], effectifs_t[, 2], type = &#39;l&#39;, ylim = c(0, max(effectifs_t[, 2])), xlab = &#39;Temps&#39;, ylab = &quot;Nombre d&#39;individus&quot;) # lapins lines(effectifs_t[, 1], effectifs_t[, 3], col = &#39;red&#39;) legend(x=4, y=12, legend=c(&quot;Lapins&quot;, &quot;Renards&quot;), col=c(&quot;black&quot;, &quot;red&quot;), lty=c(1, 1), cex=1.2) Lorsque la population de lapins croit, celle des renards croit Ã  retardement jusquâ€™Ã  ce que la population de lapin diminue jusquâ€™Ã  Ãªtre presque Ã©teinte. Dans ces conditions, la population de renard ne peut plus Ãªtre soutenue, et dÃ©croit, ce qui en retour donne lâ€™opportunitÃ© de la population de lapins de resurgir. par(mar=c(4, 4, 1, 1), ps=10) plot(effectifs_t[, 2], effectifs_t[, 3], type = &#39;l&#39;, xlab = &quot;Nombre lapins&quot;, ylab= &quot;Nombre de renards&quot;, xlim = c(0, max(effectifs_t[, 2])), ylim = c(0, max(effectifs_t[, 3]))) # isoclines abline(v=lapin_iso, lty=2, col=&quot;black&quot;) abline(h=renard_iso, lty=2, col=&quot;red&quot;) points(lapin_iso, renard_iso) # condition initiale points(y0[1], y0[2], pch = 16) Les conditions initiales sont responsables de lâ€™amplitude des cycles. En faisant les faisant varier et en portant graphiquement les vecteurs de flux, on peut mieux apprÃ©cier lâ€™importance des isoclines, qui sÃ©parent la direction que prend la relation entre deux espÃ¨ces. effectifs_i &lt;- list() lapin_0 &lt;- 1:30 for (i in 1:length(lapin_0)) { y0[1] &lt;- lapin_0[i] effectifs_i[[i]] &lt;- ode(y = y0, times = times, modele_LV, p) offsets &lt;- effectifs_i[[i]][-1, -1] - effectifs_i[[i]][-nrow(effectifs_i[[i]]), -1] colnames(offsets) &lt;- c(&quot;d_lapin&quot;, &quot;d_renard&quot;) effectifs_i[[i]] &lt;- cbind(effectifs_i[[i]][-1, ], offsets) } effectifs_df &lt;- do.call(rbind.data.frame, effectifs_i) library(&quot;plotrix&quot;) plot(effectifs_df[, 2], effectifs_df[, 3], type = &#39;n&#39;, xlab = &quot;Nombre lapins&quot;, ylab= &quot;Nombre de renards&quot;, xlim = c(0, max(effectifs_df[, 2])), ylim = c(0, max(effectifs_df[, 3]))) # isoclines abline(v=lapin_iso, lty=2, col=&quot;black&quot;) abline(h=renard_iso, lty=2, col=&quot;red&quot;) points(lapin_iso, renard_iso) vectorField(u=effectifs_df[, 4], v=effectifs_df[, 5], xpos=effectifs_df[, 2], ypos=effectifs_df[, 3], scale=0.1, headspan=0.05, vecspec=&quot;lonlat&quot;) Nous avons modÃ©lisÃ© une relation biologique de prÃ©dation. Il existe dans la littÃ©rature une panoplie de modÃ¨les dâ€™EDO pour dÃ©crire les relations biologiques, qui peuvent Ãªtre modÃ©lisÃ©s entre plusieurs espÃ¨ces pour crÃ©er des rÃ©seaux trophiques complexes. Toutefois, la difficultÃ© de collecter des donnÃ©es en quantitÃ© et en qualitÃ© suffisante rendent ces modÃ¨les difficiles Ã  apprÃ©hender. Exercice. Quâ€™adviendrait-il des populations si lâ€™on prenait plutÃ´t un profil de croissance logistique chez les lapins? \\[\\frac{dğŸ°}{dt} = rğŸ° \\left( 1-\\frac{x}{K} \\right) - \\beta ğŸ°ğŸ¦Š \\] \\[\\frac{dğŸ¦Š}{dt} = \\delta ğŸ°ğŸ¦Š - \\gamma ğŸ¦Š \\] Exercice. ModÃ©liser une compÃ©tition interspÃ©cifique oÃ¹ chaque population croit de maniÃ¨re logistique. \\[\\frac{dğŸ}{dt} = r_1 ğŸ \\left( 1-\\frac{ğŸ}{K_1} -\\alpha \\frac{ğŸ€}{K_1} \\right) \\] \\[\\frac{dğŸ}{dt} = r_2 ğŸ€ \\left( 1-\\frac{ğŸ€}{K_2} -\\beta \\frac{ğŸ}{K_2} \\right) \\] oÃ¹ \\(r_1\\) et \\(r_2\\) sont les taux de croissances respectifs des ğŸ et des ğŸ€, ainsi que \\(K_1\\) et que \\(K_2\\) sont les capacitÃ©s de support des ğŸ et des ğŸ€. Le coefficient \\(\\alpha\\) dÃ©crit lâ€™ampleur de la compÃ©tition de ğŸ€ sur ğŸ et le coefficient \\(\\beta\\) dÃ©crit lâ€™ampleur de la compÃ©tition de ğŸ sur ğŸ€ (\\(\\alpha\\) et \\(\\beta\\) sont &gt;= 0). Exercice. Les interactions biologiques forment une bonne introduction aux systÃ¨mes dâ€™Ã©quations diffÃ©rentielles ordinaires. On fait nÃ©anmoins souvent rÃ©fÃ©rence aux Ã©quations de Lorenz (1963), qui a dÃ©veloppÃ© un systÃ¨me dâ€™EDO chaotique depuis trois Ã©quations, \\[ X&#39; = aX + YZ, \\] \\[ Y&#39; = b \\left(Y-Z\\right), \\] \\[ Z&#39; = -XY + cY - Z, \\] oÃ¹ \\(X\\) est la tempÃ©rature horizontale, \\(Y\\) est la tempÃ©rature verticale, \\(Z\\) est le flux de chaleur convectif, et oÃ¹ lâ€™on retrouve les paramÃ¨tres \\(a = -8/3\\), \\(b=-10\\) et \\(c=28\\). RÃ©soudre les Ã©quations de Lorents avec deSolve. Porter graphiquement les relations entre X, Y et Z. 14.3 Les Ã©quations diffÃ©rentielles partielles en modÃ©lisation Ã©cologique Contrairement aux EDO, la solution des Ã©quations diffÃ©rentielle partielles (EDP) dÃ©pend de plus dâ€™une variable indÃ©pendante. Typiquement, elles dÃ©pendent de coordonnÃ©es spatiales. Elles peuvent aussi dÃ©pendre du temps. Dans cette section, nous allons explorer les rÃ©gimes permanents, câ€™est-Ã -dire indÃ©pendants du temps, en utilisant la mÃ©thode des diffÃ©rences finies. Nous allons aussi explorer les problÃ¨mes transitoires, qui eux dÃ©pendent du temps, en utilisant la mÃ©thode des lignes. Ã€ venirâ€¦ "]
]
