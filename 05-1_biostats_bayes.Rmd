---
title: "Biostatistiques bay√©siennes"
author: "Serge-√âtienne Parent"
date: "`r format(Sys.Date())`"
output: github_document
---

# Introduction √† l'analyse bay√©sienne en √©cologie {#chapitre-biostats-bayes}

Les statistiques bay√©siennes forment une trousse d'outils √† garder dans votre pack sack.

## Qu'est-ce que c'est?

En deux mots: mod√©lisation probabiliste. Un approche de mod√©lisation probabiliste se servant au mieux de l'information disponible. Pour calculer les probabilit√©s d'une variable inconnu en mode bay√©sien, nous avons besoin:

* De donn√©es
* D'un mod√®le
* D'une id√©e plus ou moins pr√©cise du r√©sultat avant d'avoir analys√© les donn√©es

De mani√®re plus formelle, le th√©or√®me de Bayes (qui forme la base de l'analyse bay√©seienne), dit que la distribution de probabilit√© des param√®tres d'un mod√®le (par exemple, la moyenne ou une pente) est proportionnelle √† la mutliplication de la distribution de probabilit√© estim√©e des param√®tres et la distribution de probabilit√© √©mergeant des donn√©es.

Plus formellement,

$$P\left(\theta | y \right) = \frac{P\left(y | \theta \right) \times P\left(\theta\right)}{P\left(y \right)}$$,

o√π $P\left(\theta | y \right)$ $-$ la probabilit√© d'obtenir des param√®tres $\theta$ √† partir des donn√©es $y$ $-$ est la distribution de probabilit√© *a posteriori*, calcul√©e √† partir de votre *a prioti* $P\left(\theta\right)$ $-$ la probabilit√© d'obtenir des param√®tres $\theta$ sans √©gard aux donn√©es, selon votre connaissance du ph√©nom√®ne $-$ et vos donn√©es observ√©es $P\left(y | \theta \right)$ $-$ la probabilit√© d'obtenir les donn√©es $y$ √©tant donn√©s les param√®tres $\theta$ qui r√©gissent le ph√©nom√®ne. $P\left(y\right)$, la probabilit√© d'observer les donn√©es, est appell√©e la *vraissemblance marginale*, et assure que la somme des probabilit√©s est nulle.

## Pourquoi utiliser?

Avec la notion fr√©quentielle de probabilit√©, on teste la probabilit√© d'observer les donn√©es recueillies √©tant donn√©e l'absence d'effet r√©el (qui est l'hypoth√®se nulle g√©n√©ralement adopt√©e). La notion bay√©sienne de probabilit√© combine la connaissance que l'on a d'un ph√©nom√®ne et les donn√©es observ√©es pour estimer la probabilit√© qu'il existe un effet r√©el. En d'autre mots, les stats fr√©quentielles testent si les donn√©es concordent avec un mod√®le du r√©el, tandis que les stats bay√©siennes √©valuent la probabilit√© que le mod√®le soit r√©el.

Le hic, c'est que lorsqu'on utilise les statistiques fr√©quentielles pour r√©pondre √† une question bay√©sienne, on s'expose √† de mauvaises interpr√©tations. Si l'on d√©sire, par exemple, √©valuer la probabilit√© de l'existance de vie sur Mars, on devra passer par le bay√©sien, car avec les stats fr√©quentielles, l'on devra plutpot conclure si les donn√©es sont conforme ou non avec l'hypoth√®se de la vie sur Mars (exemple tir√©e du blogue [Dynamic Ecology](https://dynamicecology.wordpress.com/2011/10/11/frequentist-vs-bayesian-statistics-resources-to-help-you-choose/)).

## Comment l'utiliser?

Bien que la formule du th√©or√®me de Bayes soit plut√¥t simple, calculer une fonction *a posteriori* demandera de passer par des algorithmes de simulation, ce qui pourrait demander une bonne puissance de calcul, et des outils appropri√©s.

En particulier, le module g√©n√©rique [`greta`](https://greta-stats.org/) permet de g√©n√©rer une panoplie de mod√®les bay√©siens.

----------------------- -----------------------------------------------
üò±\ **Installer greta**   Pour installer greta, vous devez pr√©alablement installer Python, gr√©√© des modules tensorflow et tensorflow-probability en suivant [le guide](https://greta-stats.org/articles/get_started.html). En somme, vous devez d'abord installer greta (`install.packages("greta")`). Puis vous devez installer une distribution de Python -- je vous sugg√®re [Anaconda](https://www.anaconda.com/download) (~500 Mo) ou [Miniconda](https://conda.io/miniconda.html) pour une installation minimale (~60 Mo). Enfin, lancez les commandes suivantes (une connection internet est n√©cessaire pour t√©l√©charger les modules).

                         `install_tensorflow(method = "conda")`
                         `reticulate::conda_install("r-tensorflow", "tensorflow-probability", pip = TRUE)`
-----------------------------------------------------------------------

## Faucons p√©lerins

Empruntons un exemple du livre [Introduction to WinBUGS for Ecologists: A Bayesian Approach to Regression, ANOVA and Related Analyses](https://www.elsevier.com/books/introduction-to-winbugs-for-ecologists/kery/978-0-12-378605-0), de Marc K√©ry et examinons la masse de faucons p√©lerins. Mais alors que Marc K√©ry utilise WinBUGS, un logiciel de r√©solution de probl√®me en mode bay√©sien, nous utiliserons greta.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Falco_peregrinus_-_01.jpg/1024px-Falco_peregrinus_-_01.jpg)
Source: [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Falco_peregrinus_-_01.jpg)

Pour une premi√®re approche, nous allons estimer la masse moyenne d'une population de faucons p√©lerins.

√Ä titre de donn√©es, g√©n√©rons des nombres al√©atoires. Cette strat√©gie permet de valider les statistiques en les comparant aux param√®tre que l'on impose. Ici, nous imposons une moyenne de 600 grammes et un √©cart-type de 30 grammes. G√©n√©rons une s√©ries de donn√©es avec 20 √©chantillons.

```{r}
library("tidyverse")
set.seed(5682)
y20 <- rnorm(n = 20, mean=600, sd = 30)
y200 <- rnorm(n = 200, mean=600, sd = 30)
par(mfrow = c(1, 2))
hist(y20, breaks=5)
hist(y200, breaks=20)
```

Je cr√©e une fonction qui retourne la moyenne et l'erreur sur la moyenne ou sur la distribution. Calculons les statistiques classiques.

```{r}
confidence_interval <- function(x, on="deviation", distribution="t", level=0.95) {
  m <- mean(x)
  se <- sd(x)
  n <- length(x)
  if (distribution == "t") {
    error <- se * qt((1+level)/2, n-1)
  } else if (distribution == "normal") {
    error <- se * qnorm((1+level)/2)
  }
  if (on == "error") {
    error <- error/sqrt(n)
  }
  return(c(ll = m-error, mean = m, ul = m+error))
}
```

```{r}
print("D√©viation, 95%")
print(round(confidence_interval(y20, on='deviation', level=0.95), 2))

print("Erreur, 95%")
print(round(confidence_interval(y20, on='error', level=0.95), 2))

print("√âcart-type")
print(round(sd(y20), 2))
```

En faisant cela, nous prenons pour acquis que les donn√©es sont distribu√©es normalement. En fait, nous savons qu'elles devraient l'√™tre pour de grands √©chantillons, puisque nous avons nous-m√™me g√©n√©r√© les donn√©es. Par contre, comme observateur par exemple de la s√©rie de 20 donn√©es g√©n√©r√©es, la distribution est d√©finitivement asym√©trique. Sous cet angle, la moyenne, ainsi que l'√©cart-type, pourraient √™tre des param√®tres biais√©s. Nous pouvons justifier le choix d'une loi normale par des connaissances a priori des distributions de masse parmi des esp√®ces d'oiseau. Ou bien transformer les donn√©es pour rendre leur distribution normale (chapitre \@ref(chapitre-preprocess)).

## Statistiques d'une population

### greta

En mode bay√©sien, nous devons d√©finir la connaissance *a priori* sous forme de variables al√©atoires non-observ√©es selon une distribution. Prenons l'exemple des faucons p√©lerins. Disons que nous ne savons pas √† quoi ressemble la moyenne du groupe a priori. Nous pouvons utiliser un a priori vague, o√π la masse moyenne peut prendre n'importe quelle valeur entre 0 et 2000 grammes, sans pr√©f√©rence: nous lui imposons donc un a priori selon une distribution uniforme. Idem pour l'√©cart-type

```{r}
library("greta")
library("DiagrammeR")
library ("bayesplot")
library("tidybayes")
param_mean <- uniform(min = 0, max = 2000)
param_sd <- uniform(min = 0, max = 100)
```

La fonction a porteriori inclue la fonction de vraissemblance ainsi que la connaissancew a priori.

```{r}
distribution(y20) <- normal(param_mean, param_sd)
```

Le tout forme un mod√®le pour appr√©cier y, la masse des faucons p√©lerins.

```{r}
m <- model(param_mean, param_sd)
plot(m)
```

**L√©gende**:

![](images/5-1_legende.png)


Nous pouvons enfin lancer le mod√®le .

```{r}
draws <- mcmc(m, n_samples = 1000)
```

L'inspection de l'√©chantillonnage peut √™tre effectu√©e gr√¢ce au module bayesplot.

```{r}
mcmc_combo(draws, combo = c("hist", "trace"))
```

L'√©chantillonnage semble stable. Voyons la distribution a posteriori des param√®tres.

```{r}
draws_tidy <- draws %>%
  spread_draws(param_mean, param_sd)

print("Moyenne:")
confidence_interval(x = draws_tidy$param_mean, on = "deviation", distribution = "normal", level = 0.95)

print("√âcart-type:")
confidence_interval(x = draws_tidy$param_sd, on = "deviation", distribution = "normal", level = 0.95)
```

L'*a priori* √©tant vague, les r√©sultats de l'analyse bay√©sienne sont comparables aux statistiques fr√©quentielles.

```{r}
print("Erreur, 95%")
print(round(confidence_interval(y20, on='error', level=0.95), 2))
```

Les r√©sultats des deux approches peuvent n√©anmoins √™tre interpr√©t√©s de mani√®re diff√©rente. En ce qui a trait √† la moyenne:

- **Fr√©quentiel**. Il y a une probabilit√© de 95% que mes donn√©es aient √©t√© g√©n√©r√©es √† partir d'une moyenne se situant entre 584 et 614 grammes.

- **Bay√©sien**. √âtant donn√©e mes connaissances (vagues) de la moyenne et de l'√©cart-type avant de proc√©der √† l'analyse (*a priori*), il y a une probabilit√© de 95% que la moyenne de la masse de la population se situe entre 583 et 614 grammes.

Nous avons maintenant une id√©e de la distribution de moyenne de la population. Mais, rarement, une analyse s'arr√™tera √† ce stade. Il arrive souvent que l'on doive comparer les pparam√®tres de deux, voire plusieurs groupes. Par exemple, comparer des populations vivants dans des √©cosyst√®mes diff√©rents, ou comparer un traitement √† un plac√©bo. Ou bien, comparer, dans une m√™me population de faucons p√©lerins, l'envergure des ailes des m√¢les et celle des femelles.

## Test de t: Diff√©rence entre des groupes

Pour comparer des groupes, on exprime g√©n√©ralement une hypoth√®se nulle, qui typiquement pose qu'il n'y a pas de diff√©rence entre les groupes. Puis, on choisit un test statistique **pour d√©terminer si les distributions des donn√©es observ√©es sont plausibles dans si l'hypoth√®se nulle est vraie**.

En d'autres mots, le test statistique exprime la probabilit√© que l'on obtienne les donn√©es obtenues s'il n'y avait pas de diff√©rence entre les groupes. 

Par exemple, si 

1. vous obtenez une *p-value* de moins de 0.05 apr√®s un test de comparaison et
2. l'hypoth√®se nulle pose qu'il n'y a pas de diff√©rence entre les groupes,

cela signifie qu'il y a une probabilit√© de 5% que vous ayiez obtenu ces donn√©es s'il n'y avait en fait pas de diff√©rence entre les groupe. Il serait donc peu probable que vos donn√©es euent √©t√© g√©n√©r√©es comme telles s'il n'y avait en fait pas de diff√©rence.

```{r}
n_f <- 30
moy_f <- 105
n_m <- 20
moy_m <- 77.5
sd_fm <- 2.75

set.seed(21526)
envergure_f <- rnorm(mean=moy_f, sd=sd_fm, n=n_f)
envergure_m <- rnorm(mean=moy_m, sd=sd_fm, n=n_m)

envergure_f_df <- data.frame(Sex = "Female", Wingspan = envergure_f)
envergure_m_df <- data.frame(Sex = "Male", Wingspan = envergure_m)
envergure_df <- rbind(envergure_f_df, envergure_m_df)

envergure_df %>%
  ggplot(aes(x=Wingspan)) +
  geom_histogram(aes(y=..density.., fill=Sex)) +
  geom_density(aes(linetype=Sex, y=..density..))
```

Et les statistiques des deux groupesL

```{r}
envergure_df %>%
  group_by(Sex) %>%
  summarise(mean = mean(Wingspan),
            sd = sd(Wingspan),
            n = n())
```

√âvaluer s'il y a une diff√©rence significative peut se faire avec un test de t (ou de Student).

```{r}
t.test(envergure_f, envergure_m)
```

La probabilit√© que les donn√©es ait √©t√© g√©n√©r√©es de la sorte si les deux groupes n'√©tait semblables est tr√®s faible (`p-value < 2.2e-16`). On obtiendrait sensiblement les m√™mes r√©sultats avec une r√©gression lin√©aire.

```{r}
linmod <- lm(Wingspan ~ Sex, envergure_df)
summary(linmod)
```

Le mod√®le lin√©aire est plus informatif. Il nous apprend que l'envergure des ailes des m√¢les est en moyenne plus faible de 28.0 cm que celle des femelles...

```{r}
confint(linmod, level = 0.95)
```

... avec un intervalle de confiance entre -29.6 cm √† -26.4 cm.

Utilisons l'information d√©riv√©e de statistiques classiques dans nos a priori. Oui-oui, on peut faire √ßa. Mais attention, un a priori trop pr√©cis ou trop coll√© sur nos donn√©es orientera le mod√®le vers une solution pr√©alablement √©tablie: ce qui constituerait aucune avanc√©e par rapport √† l'*a priori*. Nous allons utiliser a priori pour les deux groupes la moyenne des deux groupes, et comme dispersion la moyenne le double de l'√©cart-type. Rappelons que cet √©cart-type est l'a priori de √©cart-type sur la moyenne, non pas de la population.

Proc√©dons √† la cr√©ation d'un mod√®le greta. Nous utiliserons la r√©gression lin√©aire pr√©f√©rablement au test de t.

```{r}
is_female <- model.matrix(~envergure_df$Sex)[, 2]
```


```{r}
int <- normal(600, 30)
coef <- normal(30, 10)
sd <- cauchy(0, 10, truncation = c(0, Inf))

mu <- int + coef * is_female

distribution(envergure_df$Wingspan) <- normal(mu, sd)

m <- model(int, coef, sd, mu, sd)
plot(m)
```

Go!

```{r}
draws <- mcmc(m, n_samples = 1000)
```

Et les r√©sultats.

```{r}
mcmc_combo(draws, combo = c("hist", "trace"))
```


```{r}
draws_tidy <- draws %>%
  spread_draws(int, coef, sd)
draws_tidy
```

```{r}
print("Intercept:")
confidence_interval(x = draws_tidy$int, on = "deviation", distribution = "normal", level = 0.95)

print("Pente:")
confidence_interval(x = draws_tidy$coef, on = "deviation", distribution = "normal", level = 0.95)
```

## Pour aller plus loin

Le module greta est con√ßu et maintenu par [Nick Golding](https://github.com/goldingn), du Quantitative & Applied Ecology Group de l'University of Melbourne, Australie. La [documentation de greta](https://greta-stats.org/) offre des [recettes](https://greta-stats.org/articles/example_models.html) pour toutes sortes d'analyses en √©cologie.

Les livres de Mark K√©ry, bien que r√©dig√©s pour les calculs en langage R et WinBUGS, offre une approche bien structur√©e et traduisible en greta, qui est plus moderne que WinBUGS.

- [Introduction to WinBUGS for Ecologists (2010)](https://www.amazon.com/Introduction-WinBUGS-Ecologists-Bayesian-regression/dp/0123786053)
- [Bayesian Population Analysis using WinBUGS: A Hierarchical Perspective (2011)](https://www.amazon.com/Bayesian-Population-Analysis-using-WinBUGS/dp/0123870208)
- [Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS (2015)](https://www.amazon.com/Applied-Hierarchical-Modeling-Ecology-distribution/dp/0128013788)